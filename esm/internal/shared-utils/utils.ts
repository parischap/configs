// This module must not import any external dependency. It must be runnable without a package.json
import { Dirent } from 'node:fs';
import { readFile, readdir, writeFile } from 'node:fs/promises';
import { sep as OSSep, basename, extname, isAbsolute, join, relative } from 'node:path';
import { sep as posixSep } from 'node:path/posix';
import {
  allJavaScriptExtensions,
  autoGeneratedFileWarning,
  gitIgnoreFilename,
  prettierIgnoreFilename,
  ymlExtensions,
} from './constants.js';
import { type ReadonlyRecord, type Record, isArray, isRecord } from './types.js';

/** Returns a copy of `s` with the first character capitalized */
export const capitalizeFirstLetter = (s: string) => s.charAt(0).toUpperCase() + s.slice(1);

/** Escapes regular expression special characters */
export const regExpEscape = (s: string): string =>
  // @ts-expect-error Awaiting bug correction in typescript
  // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-return
  RegExp.escape(s);

/** Converts an OS path to a posix path */
export const fromOSPathToPosixPath =
  OSSep === posixSep ? (path: string) => path : (path: string) => path.replaceAll(OSSep, posixSep);

/** Converts a posix path to an OS path */
export const fromPosixPathToOSPath =
  OSSep === posixSep ? (path: string) => path : (path: string) => path.replaceAll(posixSep, OSSep);

/** Returns true if `p` is a subpath of `target` */
export const isSubPathOf =
  (target: string) =>
  (p: string): boolean => {
    const relPath = relative(target, p);
    return !relPath.startsWith('..') && !isAbsolute(relPath);
  };

/** Stringifies with indentation */
export const prettyStringify = (v: unknown): string => JSON.stringify(v, null, 2);

/**
 * Type-level result of merging two record types R1 and R2 used by `deepMerge2` and `deepMerge`.
 *
 * Rules:
 *
 * - Keys exclusive to R1 or R2 are preserved.
 * - Keys present in both:
 *
 *   - If both values are Records, the type is recursively merged (MergedRecord).
 *   - Otherwise the value type comes from R2 (R2 overrides).
 */
type MergedRecord<R1, R2> =
  R1 extends Record ?
    R2 extends Record ?
      {
        [key in keyof R1 as key extends keyof R2 ? never : key]: R1[key];
      } & { [key in keyof R2 as key extends keyof R1 ? never : key]: R2[key] } & {
        [key in keyof R1 as key extends keyof R2 ? key : never]: key extends keyof R2 ?
          MergedRecord<R1[key], R2[key]>
        : never;
      }
    : R2
  : R2;

/**
 * Deeply merges two objects.
 *
 * Behavior:
 *
 * - If both values are plain objects (Records), they are merged recursively.
 * - If both values are arrays, they are concatenated in order: [...first, ...second].
 * - Keys only present in one objrct are preserved.
 */
export const deepMerge2 = <R1 extends ReadonlyRecord, R2 extends ReadonlyRecord>(
  first: R1,
  second: R2,
): MergedRecord<R1, R2> => {
  const result = { ...first } as Record;

  const secondKeys = Reflect.ownKeys(second);

  for (const secondKey of secondKeys) {
    const secondValue = second[secondKey as keyof R2];
    if (secondKey in first) {
      /* @ts-expect-error Typescript should narrow first but does not */
      const firstValue: unknown = first[secondKey];
      /* eslint-disable-next-line functional/no-expression-statements, functional/immutable-data*/
      result[secondKey as string] =
        isRecord(secondValue) && isRecord(firstValue) ?
          (deepMerge2(firstValue, secondValue) as never)
        : isArray(secondValue) && isArray(firstValue) ? ([...firstValue, ...secondValue] as never)
        : secondValue;
    } else
      /* eslint-disable-next-line functional/no-expression-statements, functional/immutable-data */
      result[secondKey as string] = secondValue;
  }

  return result as never;
};

/**
 * Deep merge of multiple records.
 *
 * Wrapper over deepMerge2 which reduces an array of records into a single merged record. Supports
 * merging 2..6 arguments with proper result typing
 */
/*export const deepMerge: {
  <R1 extends ReadonlyRecord, R2 extends ReadonlyRecord>(r1: R1, r2: R2): MergedRecord<R1, R2>;
  <R1 extends ReadonlyRecord, R2 extends ReadonlyRecord, R3 extends ReadonlyRecord>(
    r1: R1,
    r2: R2,
    r3: R3,
  ): MergedRecord<MergedRecord<R1, R2>, R3>;
  <
    R1 extends ReadonlyRecord,
    R2 extends ReadonlyRecord,
    R3 extends ReadonlyRecord,
    R4 extends ReadonlyRecord,
  >(
    r1: R1,
    r2: R2,
    r3: R3,
    r4: R4,
  ): MergedRecord<MergedRecord<MergedRecord<R1, R2>, R3>, R4>;
  <
    R1 extends ReadonlyRecord,
    R2 extends ReadonlyRecord,
    R3 extends ReadonlyRecord,
    R4 extends ReadonlyRecord,
    R5 extends ReadonlyRecord,
  >(
    r1: R1,
    r2: R2,
    r3: R3,
    r4: R4,
    r5: R5,
  ): MergedRecord<MergedRecord<MergedRecord<MergedRecord<R1, R2>, R3>, R4>, R5>;
  <
    R1 extends ReadonlyRecord,
    R2 extends ReadonlyRecord,
    R3 extends ReadonlyRecord,
    R4 extends ReadonlyRecord,
    R5 extends ReadonlyRecord,
    R6 extends ReadonlyRecord,
  >(
    r1: R1,
    r2: R2,
    r3: R3,
    r4: R4,
    r5: R5,
    r6: R6,
  ): MergedRecord<MergedRecord<MergedRecord<MergedRecord<MergedRecord<R1, R2>, R3>, R4>, R5>, R6>;
} = (...Rs: ReadonlyArray<ReadonlyRecord>) => Rs.reduce(deepMerge2, {} as never) as never;*/

/**
 * Turns an array of path patterns into a regular expression. In the patterns, `*` can be used to
 * represent any number of characters except `/`
 */
export const toMiniGlobRegExp = (patterns: ReadonlyArray<string>): RegExp =>
  new RegExp(
    '^'
      + patterns.map((pattern) => regExpEscape(pattern).replace(/\*/g, '[^\\/]*')).join('|')
      + '$',
  );

/**
 * Same as node readdir but always returns Dirents. If `dontFailOnInexistentPath` is true, will not
 * fail if `path` does not exist
 */
export const readDir = async ({
  path,
  recursive,
  dontFailOnInexistentPath,
}: {
  readonly path: string;
  readonly recursive: boolean;
  readonly dontFailOnInexistentPath: boolean;
}): Promise<ReadonlyArray<Dirent>> => {
  try {
    return await readdir(path, {
      recursive,
      withFileTypes: true,
    });
  } catch (e: unknown) {
    if (dontFailOnInexistentPath && e instanceof Error && 'code' in e && e.code === 'ENOENT')
      return [];
    throw e;
  }
};

/** Returns the names of the folders of `path` */
export const readFolders = async ({
  path,
  dontFailOnInexistentPath,
}: {
  readonly path: string;
  readonly dontFailOnInexistentPath: boolean;
}): Promise<Array<string>> => {
  const contents = await readDir({ path, recursive: false, dontFailOnInexistentPath });
  return contents.filter((dirent) => dirent.isDirectory()).map(({ name }) => name);
};

/** Returns the names of the files of `path` */
export const readFiles = async ({
  path,
  dontFailOnInexistentPath,
}: {
  readonly path: string;
  readonly dontFailOnInexistentPath: boolean;
}): Promise<Array<string>> => {
  const contents = await readDir({ path, recursive: false, dontFailOnInexistentPath });
  return contents.filter((dirent) => dirent.isFile()).map(({ name }) => name);
};

/**
 * Reads the contents of the `path` folder, recursively, but excludes the top folders whose list is
 * given by `foldersToExclude`. If `dontFailOnInexistentPath` is true, will not fail if `path` does
 * not exist. For each found file returns:
 *
 * - name: the name of the file with extension
 * - bareName: the name of the file without extension
 * - extension: the extension of the file (ex: .js)
 * - parentPath: the path to the folder containing the file expressed relatively to CWD
 * - path: the path to the file expressed relatively to CWD
 * - relativeParentPath : the path to the folder containing the file expressed relatively to
 *   `relativePathSource` which is by default taken equal to `path`
 * - relativePath : the path to the the file expressed relatively to `relativePathSource` which is by
 *   default taken equal to `path`
 */
export const readFilesRecursively = async ({
  path,
  foldersToExclude,
  dontFailOnInexistentPath,
  relativePathSource = path,
}: {
  readonly path: string;
  readonly foldersToExclude: ReadonlyArray<string>;
  readonly dontFailOnInexistentPath: boolean;
  readonly relativePathSource?: string;
}): Promise<
  Array<{
    name: string;
    bareName: string;
    extension: string;
    path: string;
    parentPath: string;
    relativeParentPath: string;
    relativePath: string;
  }>
> => {
  const topContents = await readDir({ path, recursive: false, dontFailOnInexistentPath });
  const topFolders = topContents
    .filter((dirent) => dirent.isDirectory())
    .filter(({ name }) => !foldersToExclude.includes(name))
    .map(({ name }) => name);

  const otherContents = await Promise.all(
    topFolders.map((topFolderName) =>
      readDir({
        path: join(path, topFolderName),
        recursive: true,
        dontFailOnInexistentPath: false,
      }),
    ),
  );
  return [...topContents, ...otherContents.flat()]
    .filter((dirent) => dirent.isFile())
    .map(({ name, parentPath }) => {
      const extension = extname(name);
      const bareName = name.substring(0, name.length - extension.length);
      const relativeParentPath = relative(relativePathSource, parentPath);
      return {
        name,
        bareName,
        extension,
        parentPath,
        path: join(parentPath, name),
        relativeParentPath,
        relativePath: join(relativeParentPath, name),
      };
    });
};

/**
 * Reads a JSON file that must contain the JSON representation of a object
 *
 * @category Destructors
 */
export const readJsonFile = async (path: string): Promise<Record> => {
  const contents = await readFile(path, 'utf8');

  const configFile: unknown = JSON.parse(contents);

  if (!isRecord(configFile))
    throw new Error(`'${path}' must contain the json representation of a non-null object`);
  return configFile;
};

/**
 * Writes the autogenerated `newContents` prefixed with 'autoGeneratedFileWarning' at path `path`
 * only if the file does not exist or exists and starts with `autoGeneratedFileWarning`
 */
export const writeAutogeneratedFile = async ({
  path,
  newContents,
}: {
  readonly path: string;
  readonly newContents: string;
}): Promise<void> => {
  const name = basename(path);
  const extension = extname(name);

  const commentType =
    (
      ymlExtensions.includes(extension)
      || name === prettierIgnoreFilename
      || name === gitIgnoreFilename
    ) ?
      'Hashed'
    : allJavaScriptExtensions.includes(extension) ? 'Slashed'
    : 'NotSupported';

  if (commentType === 'NotSupported') return writeFile(path, newContents);

  const autoGeneratedComment = (commentType === 'Hashed' ? '#' : '//') + autoGeneratedFileWarning;
  let exists = true;
  let contents = '';
  try {
    /* eslint-disable-next-line functional/no-expression-statements */
    contents = await readFile(path, 'utf8');
  } catch (e: unknown) {
    if (e instanceof Error && 'code' in e && e['code'] === 'ENOENT')
      /* eslint-disable-next-line functional/no-expression-statements */
      exists = false;
    else throw e;
  }

  if (!exists || contents.startsWith(autoGeneratedComment)) {
    /* eslint-disable-next-line functional/no-expression-statements */
    await writeFile(path, autoGeneratedComment + newContents);
  } else
    throw new Error(`Could not autogenerate '${path}' because the file already exists \
and does not start with predefined warning comment`);
};
