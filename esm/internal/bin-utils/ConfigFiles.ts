/**
 * This module represents an object whose keys are the names of the configuration files of a package
 * and the values the contents of these files
 */
/* This module must not import any external dependency. It must be runnable without a package.json because it is used by the generate-config-files.ts bin */

import { mkdir, readFile, writeFile } from 'node:fs/promises';
import { dirname, join, parse } from 'node:path';
import {
  autoGeneratedFileWarning,
  baseDevDependencies,
  binariesFolderName,
  binariesPath,
  commonJsFolderName,
  configsDependencies,
  configsPackageName,
  configsPeerDependencies,
  docGenDependencies,
  docgenConfigFilename,
  docsConfigYmlPath,
  docsIndexMdPath,
  effectDependencies,
  effectPlatformDependencies,
  examplesFolderName,
  filesWithSlashedComments,
  gitIgnoreFilename,
  githubWorkflowsPagesPath,
  githubWorkflowsPublishPath,
  indexBareName,
  indexTsFilename,
  indexTsPath,
  internalFolderName,
  javaScriptExtensionSet,
  jsonExtensionSet,
  licenseFilename,
  madgeConfigFilename,
  owner,
  oxfmtConfigFilename,
  oxlintConfigFilename,
  packageJsonFilename,
  packageManager,
  packageSourceDevDependencies,
  packagesFolderName,
  pnpmWorkspaceFilename,
  prettierConfigFilename,
  prettierIgnoreFilename,
  prodFolderName,
  projectConfigFilename,
  repoDevDependencies,
  slashedScope,
  sourceFolderName,
  testsIndexBaseName,
  topDevDependencies,
  tsConfigBaseFilename,
  tsConfigDocGenFilename,
  tsConfigExamplesFilename,
  tsConfigFilename,
  tsConfigOthersFilename,
  tsConfigSourceFilename,
  tsConfigTestsFilename,
  tsExecuter,
  typesFolderName,
  versionControlService,
  vitestConfigFilename,
  ymlExtensionSet,
} from '../shared-utils/constants.js';
import {
  type Data,
  type ReadonlyRecord,
  capitalizeFirstLetter,
  deepMerge2,
  fromOSPathToPosixPath,
  isRecord,
  objectToYaml,
  prettyStringify,
  readFilesRecursively,
} from '../shared-utils/utils.js';
import type * as PackageLoadedBase from './Package/LoadedBase.js';
import type * as PackageLoadedNoSource from './Package/LoadedNoSource.js';
import type * as PackageLoadedSource from './Package/LoadedSource.js';
import type * as PackageMonoRepo from './Package/MonoRepo.js';
import type * as PackageOnePackageRepo from './Package/OnePackageRepo.js';
import type * as PackageTop from './Package/Top.js';
import TemplatesDocgen from './templates/Docgen.js';
import TemplatesDocsConfig from './templates/docs/Config.js';
import TemplatesGithubWorkflowsPages from './templates/github/workflows/Pages.js';
import TemplatesGithubWorkflowsPublish from './templates/github/workflows/Publish.js';
import TemplatesGitIgnore from './templates/Gitignore.js';
import TemplatesLicense from './templates/License.js';
import TemplatesMadgerc from './templates/Madgerc.js';
import TemplatesOxfmtrc from './templates/Oxfmtrc.js';
import TemplatesOxlintrcNode from './templates/OxlintrcNode.js';
import TemplatesOxlintrcPlain from './templates/OxlintrcPlain.js';
import TemplatesPnpmWorkspace from './templates/PnpmWorkspace.js';
import TemplatesPrettierIgnore from './templates/Prettierignore.js';
import TemplatesPrettierrc from './templates/Prettierrc.js';
import TemplatesTsconfig from './templates/Tsconfig.js';
import TemplatesTsconfigBase from './templates/TsconfigBase.js';
import TemplatesTsconfigDocgen from './templates/TsconfigDocgen.js';
import TemplatesTsconfigExamples from './templates/TsconfigExamples.js';
import TemplatesTsconfigOthers from './templates/TsconfigOthers.js';
import TemplatesTsconfigPlain from './templates/TsconfigPlain.js';
import TemplatesTsconfigSource from './templates/TsconfigSource.js';
import TemplatesTsconfigTests from './templates/TsconfigTests.js';
import TemplatesVitestConfig from './templates/VitestConfig.js';
import TemplatesVscodeWorkspace from './templates/VscodeWorkspace.js';

/**
 * Module tag
 *
 * @category Models
 */
export const moduleTag = '@parischap/configs/internal/bin-utils/ConfigFiles/';
const _TypeId: unique symbol = Symbol.for(moduleTag) as _TypeId;
type _TypeId = typeof _TypeId;

const TemplatesTsconfigBrowser = TemplatesTsconfigPlain;
const TemplatesTsconfigNode = TemplatesTsconfigSource;

/** Configuraton files generation mode */
export enum Mode {
  /** Generation of all configuration files in development mode */
  Dev = 0,
  /** Generation of `index.ts` and `package.json` configuration files in development mode */
  ExportsOnly = 1,
  /** Generation of all configuration files in production mode */
  Prod = 2,
}

/**
 * Type of a ConfigFiles
 *
 * @category Models
 */
export class Type {
  /**
   * Record of all the configuration files of a package. The keys are the names of the configuration
   * files and the values the contents of these files. If the key has a `json` extension, the
   * associated value is converted to a json string with JSON.stringify unless it is already a
   * string. Otherwise, the associated value is a string.
   */
  readonly configurationFiles: ReadonlyRecord<string, unknown>;

  /** Class constructor */
  private constructor(params: Data<Type>) {
    this.configurationFiles = params.configurationFiles;
  }

  /** Static constructor */
  static make(configurationFiles: ReadonlyRecord): Type {
    return new Type({ configurationFiles });
  }

  /** @internal */
  get [_TypeId](): _TypeId {
    return _TypeId;
  }
}

/**
 * Constructor
 *
 * @category Constructors
 */
export const make = (configurationFiles: ReadonlyRecord): Type => Type.make(configurationFiles);

/**
 * Returns the value of the `configurationFiles` property of `self`
 *
 * @category Destructors
 */
export const configurationFiles = (self: Type): ReadonlyRecord<string, unknown> =>
  self.configurationFiles;

/**
 * Builds a new Packagefiles from the concatenation of several ConfigFiles
 *
 * @category Constructors
 */
export const merge = (...packageFilesArr: ReadonlyArray<Type>): Type =>
  make(
    packageFilesArr.reduce(
      (acc, packageFile) => deepMerge2(acc, packageFile.configurationFiles),
      {},
    ),
  );

/**
 * Saves `self` at path `path`. Before saving, the files are converted in the following manner:
 *
 * - if the content is a string, it is saved as is
 * - if the target file is a json file, convert the content to a string with JSON.stringify
 * - if the target file is a yaml file and the content is a record, convert the content to a string a
 *   yaml converter
 * - if the target file is a JavaScript file, convert the content to a string with JSON.stringify and
 *   prepend `export default `. However, this will only work for simple objects. If the object
 *   contains functions, symbolic keys or whatever that JSON.stringify cannot render, it will fail.
 *   This does not work in particular for eslint configuration files that contain plugins.
 *
 * @category Destructors
 */
export const save =
  ({ packagePath, packageName }: { readonly packagePath: string; readonly packageName: string }) =>
  (self: Type): Promise<Array<void>> =>
    Promise.all(
      Object.entries(self.configurationFiles).map(async ([filename, fileContent]) => {
        const { ext, base } = parse(filename);
        const isYml = ymlExtensionSet.has(ext);
        const contentToWriteFunc =
          typeof fileContent === 'string' ? () => fileContent
          : jsonExtensionSet.has(ext) || base === madgeConfigFilename ?
            () => prettyStringify(fileContent)
          : isRecord(fileContent) && isYml ?
            () => objectToYaml({ errorPrefix: '', value: fileContent }).join('\n')
          : javaScriptExtensionSet.has(ext) ? () => `export default ${prettyStringify(fileContent)}`
          : () => {
              throw new Error(
                `Entry '${filename}' in '${projectConfigFilename}' must have value of type string`,
              );
            };

        const targetFilename = join(packagePath, filename);
        // Create directory in case it does not exist

        await mkdir(dirname(targetFilename), { recursive: true });
        console.log(`'${packageName}': Saving configuration file '${filename}'`);

        const commentType =
          isYml || filename === prettierIgnoreFilename || filename === gitIgnoreFilename ? 'Hashed'
          : filesWithSlashedComments.has(ext) ? 'Slashed'
          : 'NotSupported';

        if (commentType === 'NotSupported') {
          await writeFile(targetFilename, contentToWriteFunc());
        } else {
          const autoGeneratedComment =
            (commentType === 'Hashed' ? '#' : '//') + autoGeneratedFileWarning;
          let exists = true;
          let contents = '';
          try {
            contents = await readFile(targetFilename, 'utf8');
          } catch (error: unknown) {
            if (error instanceof Error && 'code' in error && error['code'] === 'ENOENT') {
              exists = false;
            } else {
              throw error;
            }
          }

          if (!exists || contents.startsWith(autoGeneratedComment)) {
            await writeFile(targetFilename, autoGeneratedComment + contentToWriteFunc());
          } else {
            throw new Error(`Could not autogenerate '${targetFilename}' because the file already exists \
and does not start with predefined warning comment`);
          }
        }
      }),
    );

/** Empty ConfigFiles instance */
export const empty = make({});

/**
 * ConfigFiles instance that implements what is necessary in all situations
 *
 * @category Instances
 */
export const anyPackage = ({
  packageLoadedBase: { name, description, isConfigsPackage },
  mode,
}: {
  readonly packageLoadedBase: PackageLoadedBase.Type;
  readonly mode: Mode;
}): Type =>
  make({
    ...(mode === Mode.Dev ?
      {
        // Used by the format script
        [prettierConfigFilename]: TemplatesPrettierrc,
        [oxfmtConfigFilename]: TemplatesOxfmtrc,
        // Used by the format script
        [prettierIgnoreFilename]: TemplatesPrettierIgnore,
        [tsConfigBaseFilename]: TemplatesTsconfigBase,
      }
    : {}),
    // Used by the format script
    [`${mode === Mode.Prod ? `${prodFolderName}/` : ''}${packageJsonFilename}`]: {
      name: `${slashedScope}${name}`,
      description,
      // Needs to be present even at the top or root of a monorepo because there are some javascript config files
      type: 'module',
      author: 'Jérôme MARTIN',
      license: 'MIT',
      ...(mode === Mode.Prod ?
        {}
      : {
          devDependencies: {
            /* Even configs needs to import itself so script can be written homogeneously in all packages */
            [`${slashedScope}${configsPackageName}`]: `git+ssh://${versionControlService}/${owner}/${configsPackageName}`,
            ...baseDevDependencies,
            ...(isConfigsPackage ? {} : configsPeerDependencies),
          },
          scripts: {
            // Tests can be run at all levels, even at non project levels because there are vitest projects
            test: 'vitest run',
            tscheck: `tsgo -b ${tsConfigFilename} --force`,
            lint: 'oxlint --type-aware --type-check --report-unused-disable-directives --disable-nested-config',
            'lint-fix': 'oxlint --type-aware --fix',
            //'lint-and-analyze': 'eslint . --stats -f json > eslint-stats.json',
            //'lint-rules': 'pnpx @eslint/config-inspector',
            format: 'prettier .',
            clean: `${tsExecuter[0]} ${binariesPath}/clean.ts -activePackageOnly`,
            'clean-config-files': `${tsExecuter[0]} ${binariesPath}/clean-config-files.ts -activePackageOnly`,
            'clean-node-modules': `${tsExecuter[0]} ${binariesPath}/clean-node-modules.ts -activePackageOnly`,
            'clean-prod': `${tsExecuter[0]} ${binariesPath}/clean-prod.ts -activePackageOnly`,
            'generate-config-files': `${tsExecuter[0]} ${binariesPath}/generate-config-files.ts -activePackageOnly`,
            'clean-all': `${tsExecuter[0]} ${binariesPath}/clean.ts`,
            'clean-all-config-files': `${tsExecuter[0]} ${binariesPath}/clean-config-files.ts`,
            'clean-all-node-modules': `${tsExecuter[0]} ${binariesPath}/clean-node-modules.ts`,
            'clean-all-prod': `${tsExecuter[0]} ${binariesPath}/clean-prod.ts`,
            'generate-all-config-files': `${tsExecuter[0]} ${binariesPath}/generate-config-files.ts`,
            'update-all-exports': `${tsExecuter[0]} ${binariesPath}/update-exports.ts`,
            'watch-all-for-exports': `${tsExecuter[0]} ${binariesPath}/update-exports.ts -watch`,
            'reinstall-all-dependencies': 'pnpm i --force',
          },
        }),
    },
  });

/**
 * ConfigFiles instance that implements what is necessary in a package that has no code (no esm
 * directory). Such a package is also a workspace.
 *
 * @category Instances
 */
export const noSourcePackage = ({
  packageLoadedNoSource: { isConfigsPackage },
  mode,
}: {
  readonly packageLoadedNoSource: PackageLoadedNoSource.Type;
  readonly mode: Mode;
}): Type =>
  make({
    ...(mode === Mode.Dev ?
      {
        // Used by the checks script
        [tsConfigFilename]: TemplatesTsconfigOthers(isConfigsPackage),
        // Used by the checks script
        [oxlintConfigFilename]: TemplatesOxlintrcPlain,
      }
    : {}),
    [`${mode === Mode.Prod ? `${prodFolderName}/` : ''}${packageJsonFilename}`]:
      mode === Mode.Prod ?
        {}
      : {
          scripts: {
            checks: 'pnpm lint',
            // --if-present is necessary because it is possible that no package in the workspace has a build script
            'build-all': 'pnpm --if-present -r build',
            // --if-present is necessary because it is possible that no package in the workspace has an auto-update-imports script
            'tscheck-all': 'pnpm -r -include-workspace-root=true tscheck',
            'lint-all': 'pnpm -r -include-workspace-root=true lint',
            'checks-all': 'pnpm -r -include-workspace-root=true checks',
            'format-all': 'pnpm -r -include-workspace-root=true format',
          },
          /*Pnpm: {
            patchedDependencies: {},
            overrides: {
              //'tsconfig-paths': '^4.0.0'
            },
          },*/
        },
  });

/**
 * ConfigFiles instance that creates the build part of a source package.
 *
 * @category Instances
 */
const sourcePackageBuild = ({
  packageLoadedSource: {
    dependencies,
    peerDependencies,
    buildMethod,
    useEffectPlatform,
    useEffectAsPeerDependency,
    isConfigsPackage,
  },
  mode,
}: {
  readonly packageLoadedSource: PackageLoadedSource.Type;
  readonly mode: Mode;
}): Type => {
  const [finalDependencies, finalPeerDependencies] =
    buildMethod === 'DeepBundling' && mode === Mode.Prod ?
      [{}, {}]
    : [
        {
          ...dependencies,
          ...(useEffectAsPeerDependency ?
            {}
          : {
              ...effectDependencies,
              ...(useEffectPlatform ? effectPlatformDependencies : {}),
            }),
          ...(isConfigsPackage ? configsDependencies : {}),
        },
        {
          ...peerDependencies,
          ...(useEffectAsPeerDependency ?
            {
              ...effectDependencies,
              ...(useEffectPlatform ? effectPlatformDependencies : {}),
            }
          : {}),
          ...(isConfigsPackage ? configsPeerDependencies : {}),
        },
      ];

  return make({
    [`${mode === Mode.Prod ? `${prodFolderName}/` : ''}${packageJsonFilename}`]: {
      ...(Object.keys(finalDependencies).length === 0 ? {} : { dependencies: finalDependencies }),
      ...(Object.keys(finalPeerDependencies).length === 0 ?
        {}
      : { peerDependencies: finalPeerDependencies }),
      ...(mode !== Mode.Prod ?
        {
          scripts: {
            compile: 'vite build',
            // Tsc builds but also generate types. All my packages ship with the sideEffects-free key in package.json. And this is perfectly well understood by vite and rollup. So annotate-pure-calls is only necessary for published packages that might be used by clients who use old bundlers. As far as I am concerned, I do not need cjs code. Likewise, this is only necessary for published packages.
            /*`tsc -b ${tsConfigSrcFilename} --force`
            + (isPublished ?
              ` && babel ${prodFolderName}/${sourceFolderName} --out-dir ${prodFolderName}/${commonJsFolderName}`
              + '--plugins @babel/transform-export-namespace-from --plugins @babel/transform-modules-commonjs  --source-maps'
            : '')
            + ` && babel ${prodFolderName} --plugins annotate-pure-calls --out-dir ${prodFolderName} --source-maps`
            + ' && pnpm prodify-lib',*/
          },
        }
      : {}),
    },
  });
};

/**
 * ConfigFiles instance that creates the visibility part of a source package.
 *
 * @category Instances
 */
const sourcePackageVisibility = ({
  packageLoadedSource: { parentName, isPublished, keywords },
  mode,
}: {
  readonly packageLoadedSource: PackageLoadedSource.Type;
  readonly mode: Mode;
}): Type =>
  make(
    isPublished ?
      mode === Mode.Prod ?
        {
          [`${prodFolderName}/${licenseFilename}`]: TemplatesLicense,
          [`${prodFolderName}/${packageJsonFilename}`]: {
            main: `./${commonJsFolderName}/${indexBareName}.js`,
            bugs: {
              url: `https://github.com/${owner}/${parentName}/issues`,
            },
            funding: [
              {
                type: 'ko-fi',
                url: `https://ko-fi.com/${owner}`,
              },
            ],
            // Put specific keywords in first position so important keywords come out first
            keywords: [...keywords, 'effect', 'typescript', 'functional-programming'],
          },
        }
      : {
          [packageJsonFilename]: {
            scripts: {
              // Called by the publish github action defined in configInternalRepo.ts/
              'build-and-publish': 'pnpm build && pnpm checks && pnpm publish-to-npm',
              // Npm publish ./dist --access=public does not work
              'publish-to-npm': `cd ${prodFolderName} && npm publish --access=public && cd ..`,
            },
          },
        }
    : mode === Mode.Prod ?
      {
        [`${prodFolderName}/${packageJsonFilename}`]: {
          private: true,
        },
      }
    : {},
  );

/**
 * ConfigFiles instance that creates the doc generation part of a source package.
 *
 * @category Instances
 */
const sourcePackageDocGen = ({
  packageLoadedSource: { hasDocGen },
  mode,
}: {
  readonly packageLoadedSource: PackageLoadedSource.Type;
  readonly mode: Mode;
}): Type =>
  hasDocGen ?
    make({
      ...(mode === Mode.Dev ?
        {
          [tsConfigDocGenFilename]: TemplatesTsconfigDocgen,
          [docgenConfigFilename]: TemplatesDocgen,
        }
      : {}),
      ...(mode !== Mode.Prod ?
        {
          [packageJsonFilename]: {
            devDependencies: docGenDependencies,
            scripts: {
              docgen: 'docgen',
            },
          },
        }
      : {}),
    })
  : empty;

/**
 * ConfigFiles instance that creates the Environment part of a source package.
 *
 * @category Instances
 */
const sourcePackageEnvironment = ({
  packageLoadedSource: { environment, isConfigsPackage },
  mode,
}: {
  readonly packageLoadedSource: PackageLoadedSource.Type;
  readonly mode: Mode;
}): Type => {
  if (mode !== Mode.Dev) {
    return empty;
  }

  const base = {
    // Used by the tscheck script
    [tsConfigFilename]: TemplatesTsconfig,
    // Used by the tsConfig file
    [tsConfigOthersFilename]: TemplatesTsconfigOthers(isConfigsPackage),
    // Used by the tsConfig file
    [tsConfigExamplesFilename]: TemplatesTsconfigExamples,
    // Used by the tsConfig file
    [tsConfigTestsFilename]: TemplatesTsconfigTests,
  };

  if (environment === 'Browser') {
    return make({
      ...base,
      // Used by the checks script
      [tsConfigSourceFilename]: TemplatesTsconfigBrowser,
      // Used by the checks script
      // We don't use any dom specifities because it must run on the server. It's all hidden away in preact
      [oxlintConfigFilename]: TemplatesOxlintrcPlain,
    });
  }

  if (environment === 'Node') {
    return make({
      ...base,
      // Used by the checks script
      [tsConfigSourceFilename]: TemplatesTsconfigNode,
      // Used by the checks script
      [oxlintConfigFilename]: TemplatesOxlintrcNode,
    });
  }

  return make({
    ...base,
    // Used by the checks script
    [tsConfigSourceFilename]: TemplatesTsconfigPlain,
    // Used by the checks script
    [oxlintConfigFilename]: TemplatesOxlintrcPlain,
  });
};

/**
 * ConfigFiles instance that implements what is necessary in a package that has code (an esm
 * directory). This package is also a workspace
 */
/*
 * For a one-package repo, name and parentName are the same. For a sub package, name is the
 * name of the sub package and parentName the name of the monorepo that contains it.
 */
export const sourcePackage = async ({
  packageLoadedSource,
  mode,
}: {
  readonly packageLoadedSource: PackageLoadedSource.Type;
  readonly mode: Mode;
}): Promise<Type> => {
  const {
    name,
    parentName,
    path,
    devDependencies,
    examples,
    packagePrefix,
    isPublished,
    useEffectPlatform,
  } = packageLoadedSource;

  const sourceFiles =
    packagePrefix === undefined ?
      []
    : (
        await readFilesRecursively({
          dontFailOnInexistentPath: false,
          foldersToExclude: new Set([internalFolderName, binariesFolderName]),
          path: join(path, sourceFolderName),
        })
      )
        .map((file) => ({
          ...file,
          isJavascript: javaScriptExtensionSet.has(file.extension),
          isOther: jsonExtensionSet.has(file.extension),
        }))
        .filter(({ bareName, isJavascript, isOther }) => {
          const dotPos = bareName.indexOf('.');
          return (
            bareName.slice(0, dotPos === -1 ? undefined : dotPos) !== indexBareName
            && (isJavascript || isOther)
          );
        })
        .map(({ bareName, relativeParentPath, isJavascript, extension }) => {
          const barePath = fromOSPathToPosixPath(join(relativeParentPath, bareName));
          return {
            barePath,
            extension,
            isJavascript,
            namespaceExportName: `${packagePrefix}${barePath
              .split(/[/.]/)
              .map(capitalizeFirstLetter)
              .join('')}`,
          };
        });

  const sourceFilesForExports = [
    { barePath: indexBareName, extension: '.ts', isJavascript: true, namespaceExportName: '.' },
    ...(mode === Mode.Prod ?
      []
    : [
        {
          barePath: testsIndexBaseName,
          extension: '.ts',
          isJavascript: true,
          namespaceExportName: './tests',
        },
      ]),
    ...sourceFiles.map((sourceFile) => ({
      ...sourceFile,
      namespaceExportName: `./${sourceFile.namespaceExportName}`,
    })),
  ];

  return merge(
    make({
      ...(mode === Mode.Dev ?
        {
          // Used by the circular script
          [madgeConfigFilename]: TemplatesMadgerc,
        }
      : {}),
      ...(mode === Mode.Prod ?
        {
          [`${prodFolderName}/${packageJsonFilename}`]: {
            module: `./${sourceFolderName}/${indexBareName}.js`,
            types: `./${typesFolderName}/${indexBareName}.d.ts`,
            sideEffects: [],
            // Must be present even for private packages as it can be used for other purposes
            repository: {
              type: 'git',
              // Use git+https protocol as specified in npm documentation
              url: `git+https://${versionControlService}/${owner}/${parentName}.git`,
              ...(name === parentName ?
                {}
              : {
                  directory: `${packagesFolderName}/${name}`,
                }),
            },
            // Must be present even for private packages as it can be used for instance by docgen
            homepage:
              // Use https protocol as specified in npm documentation
              `https://${versionControlService}/${owner}/${parentName}`
              + (name === parentName ? '' : `/tree/master/${packagesFolderName}/${name}`),
            exports: Object.fromEntries(
              sourceFilesForExports.map(
                ({ barePath, namespaceExportName, isJavascript }) =>
                  [
                    namespaceExportName,
                    {
                      ...(isJavascript ? { types: `./${typesFolderName}/${barePath}.d.ts` } : {}),
                      ...(isJavascript && isPublished ?
                        { require: `./${commonJsFolderName}/${barePath}.js` }
                      : {}),
                      default: `./${sourceFolderName}/${barePath}.js`,
                    },
                  ] as const,
              ),
            ),
          },
        }
      : {
          [packageJsonFilename]: {
            devDependencies: {
              ...packageSourceDevDependencies,
              // Effect platform is used as peerDependency by @effect/experimental. But only include it if not used otherwise
              ...(useEffectPlatform ?
                {}
              : {
                  ...effectPlatformDependencies,
                }),
              ...devDependencies,
            },
            exports: Object.fromEntries(
              sourceFilesForExports.map(
                ({ barePath, namespaceExportName, extension }) =>
                  [
                    namespaceExportName,
                    {
                      default: `./${sourceFolderName}/${barePath}${extension}`,
                    },
                  ] as const,
              ),
            ),
            module: `./${sourceFolderName}/${indexTsFilename}`,
            scripts: {
              build: `pnpm clean-prod && pnpm compile && cd ${prodFolderName} && pnpm i && cd ..`,
              checks: 'pnpm circular && pnpm lint && pnpm test',
              circular: `madge --extensions ts --circular --no-color --no-spinner ${sourceFolderName}`,
              'clean-prod': `pnpm rmrf ${prodFolderName} && pnpm mkdirp ${prodFolderName}`,
              examples: examples
                .map((exampleName) => `${tsExecuter[0]} ${examplesFolderName}/${exampleName}`)
                .join('&&'),
              tsconfig: `tsc --showConfig --project ${tsConfigSourceFilename}`,
              'update-exports': `${tsExecuter[0]} ${binariesPath}/update-exports.ts -activePackageOnly`,
              'watch-for-exports': `${tsExecuter[0]} ${binariesPath}/update-exports.ts -watch -activePackageOnly`,
            },
          },
          ...(packagePrefix === undefined ?
            {}
          : {
              [indexTsPath]: sourceFiles
                .filter(({ isJavascript }) => isJavascript)
                // Path.join removes upfront './' but typescript requires them so we must add them
                .map(
                  ({ barePath, namespaceExportName }) =>
                    `export * as ${namespaceExportName} from './${barePath}.js';`,
                )
                .join('\n'),
            }),
        }),
    }),
    sourcePackageVisibility({ mode, packageLoadedSource }),
    sourcePackageBuild({ mode, packageLoadedSource }),
    sourcePackageDocGen({ mode, packageLoadedSource }),
    sourcePackageEnvironment({ mode, packageLoadedSource }),
  );
};

const repoVisibility = ({
  packageRepo: { isPublished },
  mode,
}: {
  readonly packageRepo: PackageMonoRepo.Type | PackageOnePackageRepo.Type;
  readonly mode: Mode;
}): Type =>
  mode === Mode.Dev && isPublished ?
    make({
      /* Github actions need to be at the root of the github repo. This action calls a script `build-and-publish` but changes the working directory to the published package directory before calling it. So the `build-and-publish` script must be in sourcePackage.
       */
      [githubWorkflowsPublishPath]: TemplatesGithubWorkflowsPublish,
    })
  : empty;

/**
 * ConfigFiles instance that implements the docGen part of a repo
 *
 * @category Instances
 */
const repoDocGen = ({
  packageRepo: { name, description, hasDocGen },
  mode,
}: {
  readonly packageRepo: PackageMonoRepo.Type | PackageOnePackageRepo.Type;
  readonly mode: Mode;
}): Type =>
  hasDocGen ?
    make({
      ...(mode === Mode.Dev ?
        {
          /* Github actions need to be at the root of the github repo. This action calls a script `prepare-docs'`  */
          [githubWorkflowsPagesPath]: TemplatesGithubWorkflowsPages,
          // Used by the github pages.yml action
          [docsIndexMdPath]: description,
          // Used by the github pages.yml action
          [docsConfigYmlPath]: TemplatesDocsConfig({ name }),
        }
      : {}),
      ...(mode !== Mode.Prod ?
        {
          [packageJsonFilename]: {
            scripts: {
              // --if-present is necessary because it is possible that no package in the workspace has a docgen script
              'prepare-docs':
                'pnpm -r --if-present -include-workspace-root=true --parallel --aggregate-output docgen && compile-docs',
            },
          },
        }
      : {}),
    })
  : empty;

/**
 * ConfigFiles instance that implements what is necessary at the root of a git (and github) repo
 *
 * @category Instances
 */
export const repo = ({
  packageRepo,
  mode,
}: {
  readonly packageRepo: PackageMonoRepo.Type | PackageOnePackageRepo.Type;
  readonly mode: Mode;
}): Type =>
  merge(
    make({
      ...(mode === Mode.Dev ? { [gitIgnoreFilename]: TemplatesGitIgnore } : {}),
      ...(mode !== Mode.Prod ?
        {
          [packageJsonFilename]: {
            devDependencies: repoDevDependencies,
          },
        }
      : {}),
    }),

    repoDocGen({ mode, packageRepo }),
    repoVisibility({ mode, packageRepo }),
  );

/**
 * ConfigFiles instance that implements the workspace part of a top repo
 *
 * @category Instances
 */
export const top = ({
  packageTop: { name, allSourcePackagesNames, allPackagesPaths },
  mode,
}: {
  readonly packageTop: PackageTop.Type;
  readonly mode: Mode;
}): Type =>
  make({
    ...(mode === Mode.Dev ?
      {
        [pnpmWorkspaceFilename]: TemplatesPnpmWorkspace({ allSourcePackagesNames }),
        // Used by vscode
        [`${name}.code-workspace`]: TemplatesVscodeWorkspace({
          allPackagesPaths,
        }),
        // Used by vscode
        [vitestConfigFilename]: TemplatesVitestConfig(name),
      }
    : {}),
    ...(mode !== Mode.Prod ?
      {
        [packageJsonFilename]: {
          devDependencies: topDevDependencies,
          packageManager: packageManager.join('@'),
          /*Pnpm: {
      patchedDependencies: {},
      overrides: {
        //'tsconfig-paths': '^4.0.0'
      },
    },*/
        },
      }
    : {}),
  });
