/**
 * This module represents an object whose keys are the names of the configuration files of a package
 * and the values the contents of these files
 */
/* This module must not import any external dependency. It must be runnable without a package.json because it is used by the generate-config-files.ts bin */
import { readFileSync } from 'node:fs';
import { mkdir } from 'node:fs/promises';
import { dirname, extname, join } from 'node:path';
import {
  allFilesPattern,
  allJavaScriptExtensions,
  allJsonExtensions,
  allTsFiles,
  baseDevDependencies,
  binariesFolderName,
  binariesPath,
  binUtilsAssetsFolderName,
  commonJsFolderName,
  configsDependencies,
  configsPackageName,
  configsPeerDependencies,
  docgenConfigFilename,
  docGenDependencies,
  docsConfigYmlPath,
  docsFolderName,
  docsIndexMdPath,
  effectDependencies,
  effectPlatformDependencies,
  eslintConfigFilename,
  examplesFolderName,
  examplesMark,
  filesGeneratedByThirdParties,
  foldersGeneratedByThirdParties,
  foldersWithoutConfigFiles,
  githubWorkflowsPagesPath,
  githubWorkflowsPublishPath,
  gitIgnoreFilename,
  indexBareName,
  indexTsPath,
  internalFolderName,
  madgeConfigFilename,
  npmFolderName,
  othersFolderName,
  othersMark,
  owner,
  packageJsonFilename,
  packageManager,
  packagesFolderName,
  pnpmWorkspaceFilename,
  prettierConfigFilename,
  prettierIgnoreFilename,
  prodFolderName,
  projectConfigFilename,
  slashedScope,
  sourceDevDependencies,
  sourceFolderName,
  srcMark,
  testsFolderName,
  testsIndexBaseName,
  testsMark,
  tsBuildInfoFolderName,
  tsconfigBasePath,
  tsConfigDocGenFilename,
  tsConfigExamplesFilename,
  tsConfigFilename,
  tsConfigOthersFilename,
  tsConfigSrcFilename,
  tsConfigStyleIncludeForExampleFiles,
  tsConfigStyleIncludeForSourceFiles,
  tsConfigStyleIncludeForTestsFiles,
  tsConfigTestsFilename,
  tsExecuter,
  typesFolderName,
  versionControlService,
  viteConfigFilename,
  vitestConfigFilename,
} from '../../constants.js';
import { type Data, type ReadonlyRecord, type StringRecord } from '../shared-utils/types.js';
import {
  capitalizeFirstLetter,
  deepMerge2,
  fromOSPathToPosixPath,
  prettyStringify,
  readFilesRecursively,
  writeAutogeneratedFile,
} from '../shared-utils/utils.js';

const PRETTIER_CONFIG = `import {config} from '@parischap/configs/PrettierConfig';
export default config`;

const PRETTIER_IGNORE: string = [
  ...foldersGeneratedByThirdParties.map((folderName) => `/${folderName}/`),
  ...filesGeneratedByThirdParties.map((fileName) => `/${fileName}`),
].join('\n');

const ESLINT_CONFIG_BROWSER_SOURCE = `import {browserEslintConfig} from '@parischap/configs/EslintConfig';
export default browserEslintConfig({tsconfigRootDir:import.meta.dirname})`;

const ESLINT_CONFIG_NODE_SOURCE = `import {nodeEslintConfig} from '@parischap/configs/EslintConfig';
export default nodeEslintConfig({tsconfigRootDir:import.meta.dirname})`;

const ESLINT_CONFIG_PLAIN_SOURCE = `import {plainEslintConfig} from '@parischap/configs/EslintConfig';
export default plainEslintConfig({tsconfigRootDir:import.meta.dirname})`;

const ESLINT_CONFIG_OTHERS = `import {plainEslintConfig} from '@parischap/configs/EslintConfig';
export default plainEslintConfig({tsconfigRootDir:import.meta.dirname})`;

/* General tsconfig.json file. It references four sub-projects, each with its own environments (node available or not):
- the source sub-project where the package modules are located.
- the examples sub-project where example modules are located. The examples sub-project will usually use the node environment. Even if the examples sub-project has the exact same configuration as the source sub-project, they must be seperated because building the source project can always be necessary.
- the tests sub-project where test modules are located. The tests sub-project will usually use the node environment. Even if the tests sub-project has the exact same configuration as the source sub-project, they must be seperated because building the source project can always be necessary.
- the others sub-project which covers all configuration modules (eslint.config.ts, prettier.config.ts, vitest.config.ts,...). The others sub-project uses the node environment.
*/
const TSCONFIG: ReadonlyRecord = {
  include: [],
  references: [
    { path: tsConfigSrcFilename },
    { path: tsConfigExamplesFilename },
    { path: tsConfigTestsFilename },
    { path: tsConfigOthersFilename },
  ],
};

const TSCONFIG_SOURCE = {
  extends: tsconfigBasePath,
  include: [tsConfigStyleIncludeForSourceFiles],
  compilerOptions: {
    tsBuildInfoFile: `${tsBuildInfoFolderName}/${srcMark}.tsbuildinfo`,
    rootDir: '.',
    outDir: prodFolderName,
    declarationDir: `${prodFolderName}/${typesFolderName}`,
    // For some reason, Typescript needs to Emit declarations of this project referenced by the tests and examples projects
    noEmit: false,
    emitDeclarationOnly: true,
    //declarationMap: true,
  },
};

const TSCONFIG_BROWSER_SOURCE: ReadonlyRecord = deepMerge2(TSCONFIG_SOURCE, {
  compilerOptions: {
    types: [],
    /* We don't use any dom specifities in our client code because it must runnable on the server. DOM manipulation is taken care of by preact */
    //lib: ['DOM', 'DOM.Iterable'],
  },
});

const TSCONFIG_NODE_SOURCE: ReadonlyRecord = TSCONFIG_SOURCE;

const TSCONFIG_PLAIN_SOURCE: ReadonlyRecord = deepMerge2(TSCONFIG_SOURCE, {
  compilerOptions: {
    types: [],
  },
});

const TSCONFIG_EXAMPLES: ReadonlyRecord = {
  extends: tsconfigBasePath,
  include: [tsConfigStyleIncludeForExampleFiles],
  // The examples project needs to import the source project. The other possibility would be to create a package.json in the tests folder
  references: [{ path: tsConfigSrcFilename }],
  compilerOptions: {
    tsBuildInfoFile: `${tsBuildInfoFolderName}/${examplesMark}.tsbuildinfo`,
    rootDir: '.',
    outDir: prodFolderName,
    declarationDir: `${prodFolderName}/${examplesFolderName}/${typesFolderName}`,
    //declarationMap: true
  },
};

const TSCONFIG_TESTS: ReadonlyRecord = {
  extends: tsconfigBasePath,
  include: [tsConfigStyleIncludeForTestsFiles],
  // The tests project needs to import the source project. The other possibility would be to create a package.json in the tests folder
  references: [{ path: tsConfigSrcFilename }],
  compilerOptions: {
    tsBuildInfoFile: `${tsBuildInfoFolderName}/${testsMark}.tsbuildinfo`,
    rootDir: '.',
    outDir: prodFolderName,
    declarationDir: `${prodFolderName}/${testsFolderName}/${typesFolderName}`,
    //declarationMap: true,
  },
};

// Must work at all levels: top, monorepo, one-package repo, subrepo
const TSCONFIG_OTHERS: ReadonlyRecord = {
  extends: tsconfigBasePath,
  exclude: [...foldersWithoutConfigFiles, ...filesGeneratedByThirdParties],
  compilerOptions: {
    tsBuildInfoFile: `${tsBuildInfoFolderName}/${othersMark}.tsbuildinfo`,
    rootDir: '.',
    outDir: `${prodFolderName}/${othersFolderName}`,
    declarationDir: `${prodFolderName}/${othersFolderName}/${typesFolderName}`,
    //declarationMap: true
  },
};

/**
 * Specific tsconfig used by docgen. Some examples can be provided as jsdoc comments and these
 * examples usually require the node environment
 */
const TSCONFIG_DOCGEN: ReadonlyRecord = {
  extends: tsconfigBasePath,
  include: `${sourceFolderName}/${allFilesPattern}`,
  compilerOptions: {
    allowJs: false,
    checkJs: false,
  },
};

const GIT_IGNORE = [
  ...foldersGeneratedByThirdParties.map((folderName) => `/${folderName}/`),
  ...filesGeneratedByThirdParties.map((fileName) => `/${fileName}`),
].join('\n');

/*Although it is possible to have the vitest configuration inside the vite configuration files, this is usually not a good idea. The vite configuration is useful for bundling whereas the vitest configuration is useful for testing */
const VITEST_CONFIG_SOURCE = (
  name: string,
) => `import {config} from '@parischap/configs/VitestConfigSource';
export default config('${name}')`;

const VITEST_CONFIG_NO_SOURCE = `import {config} from '@parischap/configs/VitestConfigNoSource';
export default config`;

const VITE_CONFIG_TRANSPILE = `import { defineConfig } from 'vite';

export default defineConfig({});`;

const VITE_CONFIG_BUNDLE = `/// <reference types="vitest" />
import { defineConfig } from 'vite';

export default defineConfig();`;

const MADGE_CONFIG = `{
	"detectiveOptions": {
		"ts": {
			"skipTypeImports": true
		}
	}
}`;

const PNPM_WORKSPACE_CONFIG = `packages:
  - '${packagesFolderName}/*'
  - '${packagesFolderName}/*/${packagesFolderName}/*'

shellEmulator: true`;

const VSCODE_WORKSPACE_CONFIG = ({
  name,
  allPackagesPaths,
}: {
  readonly name: string;
  allPackagesPaths: ReadonlyArray<string>;
}) =>
  prettyStringify({
    folders: allPackagesPaths.map((path) => ({ path })),
    settings: {
      'typescript.tsdk': `${name}/${npmFolderName}/typescript/lib`,
    },
  });

/**
 * Publishes a sub-package or a one-package repo to npm. Can be started manually. In that case, it
 * uses the release number of the last issued release. It can be useful if the publish action has
 * failed and no modification to the code is necessary. If a modification to the code is necessary,
 * a new release will have to be issued.
 */
const GITHUB_WORKFLOWS_PUBLISH_SCRIPT = readFileSync(
  join(import.meta.dirname, binUtilsAssetsFolderName, githubWorkflowsPublishPath),
  'utf8',
);

/** Creates the documentation for the package. Must be started manually. */
const GITHUB_WORKFLOWS_PAGES_SCRIPT = readFileSync(
  join(import.meta.dirname, binUtilsAssetsFolderName, githubWorkflowsPagesPath),
  'utf8',
);

const DOCGEN_CONFIG: ReadonlyRecord = {
  parseCompilerOptions: `./${tsConfigDocGenFilename}`,
  examplesCompilerOptions: `./${tsConfigDocGenFilename}`,
  srcDir: `./${sourceFolderName}`,
  outDir: docsFolderName,
  exclude: [
    ...allTsFiles.map((ext) => `${sourceFolderName}/${internalFolderName}/${ext}`),
    `${sourceFolderName}/index.ts`,
  ],
  enforceDescriptions: true,
  enforceVersion: false,
};

const JUST_THE_DOCS_CONFIG = (name: string) => `remote_theme: mikearnaldi/just-the-docs
search_enabled: true
aux_links:
  "GitHub":
    - "//github.com/${owner}/${name}"`;

/**
 * Type of a ConfigFiles
 *
 * @category Models
 */
export class Type {
  /**
   * Record of all the configuration files of a package. The keys are the names of the configuration
   * files and the values the contents of these files. If the key has a `json` extension, the
   * associated value is converted to a json string with JSON.stringify unless it is already a
   * string. Otherwise, the associated value is a string.
   */
  readonly configurationFiles: ReadonlyRecord;

  /** Class constructor */
  private constructor(params: Data<Type>) {
    this.configurationFiles = params.configurationFiles;
  }

  /** Static constructor */
  static make(configurationFiles: ReadonlyRecord): Type {
    return new Type({ configurationFiles });
  }
}

/**
 * Constructor
 *
 * @category Constructors
 */
export const make = (configurationFiles: ReadonlyRecord): Type => Type.make(configurationFiles);

/**
 * Returns the value of the `configurationFiles` property of self
 *
 * @category Destructors
 */
export const configurationFiles = (self: Type): ReadonlyRecord => self.configurationFiles;

/**
 * Returns the value of the `configurationFiles` property of self
 *
 * @category Destructors
 */
export const filterExportsFiles = (self: Type): Type =>
  make(
    Object.fromEntries(
      Object.entries(self.configurationFiles).filter(
        ([filename]) => filename === indexTsPath || filename === packageJsonFilename,
      ),
    ),
  );

/**
 * Builds a new Packagefiles from the concatenation of several ConfigFiles
 *
 * @category Constructors
 */
export const merge = (...packageFilesArr: ReadonlyArray<Type>): Type =>
  make(
    packageFilesArr.reduce(
      (acc, packageFile) => deepMerge2(acc, packageFile.configurationFiles),
      {},
    ),
  );

/**
 * Saves `self` at path `path`
 *
 * @category Destructors
 */
export const save =
  ({ packagePath, packageName }: { readonly packagePath: string; readonly packageName: string }) =>
  async (self: Type) => {
    for (const [filename, fileContent] of Object.entries(self.configurationFiles)) {
      const contentToWriteFunc =
        typeof fileContent === 'string' ? () => fileContent
        : extname(filename) === '.json' ? () => prettyStringify(fileContent)
        : () => {
            throw new Error(
              `Entry '${filename}' in '${projectConfigFilename}' must have value of type string`,
            );
          };

      const targetFilename = join(packagePath, filename);
      // Create directory in case it does not exist
      /* eslint-disable-next-line functional/no-expression-statements*/
      await mkdir(dirname(targetFilename), { recursive: true });
      console.log(`'${packageName}': Saving configuration file '${filename}'`);
      /* eslint-disable-next-line functional/no-expression-statements*/
      await writeAutogeneratedFile({ path: targetFilename, newContents: contentToWriteFunc() });
    }
  };

/** Empty ConfigFiles instance */
export const empty = make({});

/**
 * ConfigFiles instance that implements what is necessary in all situations
 *
 * @category Instances
 */
export const anyPackage = ({
  name,
  description,
  scripts = {},
}: {
  readonly name: string;
  readonly description: string;
  readonly scripts?: StringRecord;
}): Type =>
  make({
    // Used by the format script
    [prettierConfigFilename]: PRETTIER_CONFIG,
    // Used by the format script
    [prettierIgnoreFilename]: PRETTIER_IGNORE,
    [packageJsonFilename]: {
      name: `${slashedScope}${name}`,
      description,
      // Needs to be present even at the top or root of a monorepo because there are some javascript config files
      type: 'module',
      author: 'Jérôme MARTIN',
      license: 'MIT',
      scripts: {
        // tests can be run at all levels, even at non project levels because there are vitest projects
        test: 'vitest run',
        tscheck: `tsc -b ${tsConfigFilename} --force`,
        lint: 'eslint .',
        'lint-and-analyze': 'eslint . --stats -f json > eslint-stats.json',
        'lint-rules': 'pnpx @eslint/config-inspector',
        format: 'prettier . --write',
        'clean-config-files': `${tsExecuter} ${binariesPath}/clean-config-files.ts -activePackageOnly`,
        'clean-node-modules': `${tsExecuter} ${binariesPath}/clean-node-modules.ts -activePackageOnly`,
        'clean-prod': `${tsExecuter} ${binariesPath}/clean-prod.ts -activePackageOnly`,
        'generate-config-files': `${tsExecuter} ${binariesPath}/generate-config-files.ts -activePackageOnly`,
        'clean-all-config-files': `${tsExecuter} ${binariesPath}/clean-config-files.ts`,
        'clean-all-node-modules': `${tsExecuter} ${binariesPath}/clean-node-modules.ts`,
        'clean-all-prod': `${tsExecuter} ${binariesPath}/clean-prod.ts`,
        'generate-all-config-files': `${tsExecuter} ${binariesPath}/generate-config-files.ts`,
        'reinstall-all-dependencies': 'pnpm i --force',
        ...scripts,
      },
      devDependencies: {
        /* Even configs needs to import itself so script can be written homogeneously in all packages */
        [`${slashedScope}${configsPackageName}`]: `git+ssh://${versionControlService}/${owner}/${configsPackageName}`,
        ...baseDevDependencies,
      },
    },
  });

/**
 * ConfigFiles instance that implements what is necessary in a package that has no code (no esm
 * directory). Such a package is also a workspace.
 *
 * @category Instances
 */
export const noSourcePackage: Type = make({
  // Used by the checks script
  [tsConfigFilename]: TSCONFIG_OTHERS,
  // Used by the checks script
  [eslintConfigFilename]: ESLINT_CONFIG_OTHERS,
  // Used by the test script
  [vitestConfigFilename]: VITEST_CONFIG_NO_SOURCE,
  [packageJsonFilename]: {
    scripts: {
      checks: 'pnpm tscheck && pnpm lint',
      // --if-present is necessary because it is possible that no package in the workspace has a build script
      'build-all': 'pnpm --if-present -r build',
      // --if-present is necessary because it is possible that no package in the workspace has an auto-update-imports script
      'auto-update-imports-for-all':
        'pnpm --if-present -r --parallel --aggregate-output auto-update-imports',
      // --if-present is necessary because it is possible that no package in the workspace has an update-imports script
      'update-imports-for-all': 'pnpm --if-present -r --parallel --aggregate-output update-imports',
      'tscheck-all': 'pnpm -r -include-workspace-root=true tscheck',
      'lint-all': 'pnpm -r -include-workspace-root=true lint',
      'checks-all': 'pnpm -r -include-workspace-root=true checks',
      'format-all': 'pnpm -r -include-workspace-root=true format',
    },

    /*pnpm: {
        patchedDependencies: {},
        overrides: {
          //'tsconfig-paths': '^4.0.0'
        },
      },*/
  },
});

/**
 * ConfigFiles instance that creates the build part of a source package.
 *
 * @category Instances
 */
const sourcePackageBuild = ({
  buildMethod,
  isPublished,
}: {
  readonly buildMethod: string;
  readonly isPublished: boolean;
}): Type => {
  if (buildMethod === 'None') return make({});

  if (buildMethod === 'Transpile')
    return make({
      [viteConfigFilename]: VITE_CONFIG_TRANSPILE,
      [packageJsonFilename]: {
        sideEffects: [],
        scripts: {
          compile:
            // tsc builds but also generate types. All my packages ship with the sideEffects-free key in package.json. And this is perfectly well understood by vite and rollup. So annotate-pure-calls is only necessary for published packages that might be used by clients who use old bundlers. As far as I am concerned, I do not need cjs code. Likewise, this is only necessary for published packages.
            `tsc -b ${tsConfigSrcFilename} --force`
            + (isPublished ?
              ` && babel ${prodFolderName}/${sourceFolderName} --out-dir ${prodFolderName}/${commonJsFolderName}`
              + '--plugins @babel/transform-export-namespace-from --plugins @babel/transform-modules-commonjs  --source-maps'
            : '')
            + ` && babel ${prodFolderName} --plugins annotate-pure-calls --out-dir ${prodFolderName} --source-maps`
            + ' && pnpm prodify-lib',
        },
      },
    });
  if (buildMethod === 'Bundle')
    return make({
      [viteConfigFilename]: VITE_CONFIG_BUNDLE,
      [packageJsonFilename]: {
        module: `./${sourceFolderName}/index.js`,
        scripts: {
          bundle: 'bundle-files',
          compile: `pnpm bundle && pnpm prodify-bundle`,
        },
      },
    });

  // 'BundleWithDeps' , 'AppClient'
  throw new Error(`Disallowed value for 'buildMethod' parameter. Actual: '${buildMethod}'`);
};

/**
 * ConfigFiles instance that creates the visibility part of a source package.
 *
 * @category Instances
 */
const sourcePackageVisibility = ({
  parentName,
  isPublished,
  keywords,
}: {
  readonly parentName: string;
  readonly isPublished: boolean;
  readonly keywords: ReadonlyArray<string>;
}): Type =>
  make(
    isPublished ?
      {
        [packageJsonFilename]: {
          bugs: {
            url: `https://github.com/${owner}/${parentName}/issues`,
          },
          funding: [
            {
              type: 'ko-fi',
              url: 'https://ko-fi.com/parischap',
            },
          ],
          // Put specific keywords in first position so important keywords come out first
          keywords: [...keywords, 'effect', 'typescript', 'functional-programming'],
          scripts: {
            // Called by the publish github action defined in configInternalRepo.ts/
            'build-and-publish': 'pnpm build && pnpm checks && pnpm publish-to-npm',
            // npm publish ./dist --access=public does not work
            'publish-to-npm': `cd ${prodFolderName} && npm publish --access=public && cd ..`,
          },
        },
      }
    : {
        [packageJsonFilename]: {
          private: true,
        },
      },
  );

/**
 * ConfigFiles instance that creates the doc generation part of a source package.
 *
 * @category Instances
 */
const sourcePackageDocGen = ({ hasDocGen }: { readonly hasDocGen: boolean }): Type =>
  make(
    hasDocGen ?
      {
        [packageJsonFilename]: {
          scripts: {
            docgen: 'docgen',
          },
          devDependencies: docGenDependencies,
        },
        [tsConfigDocGenFilename]: TSCONFIG_DOCGEN,
        [docgenConfigFilename]: DOCGEN_CONFIG,
      }
    : {},
  );

/**
 * ConfigFiles instance that creates the Effect Platform part of a source package.
 *
 * @category Instances
 */
const sourcePackagePlatform = ({
  useEffectPlatform,
}: {
  readonly useEffectPlatform: string;
}): Type => {
  if (useEffectPlatform === 'No') return make({});

  if (useEffectPlatform === 'AsDependency')
    return make({
      [packageJsonFilename]: {
        dependencies: effectPlatformDependencies,
      },
    });

  if (useEffectPlatform === 'AsPeerDependency')
    return make({
      [packageJsonFilename]: {
        peerDependencies: effectPlatformDependencies,
      },
    });

  throw new Error(
    `Disallowed value for 'useEffectPlatform' parameter. Actual: '${useEffectPlatform}'`,
  );
};

/**
 * ConfigFiles instance that creates the Environment part of a source package.
 *
 * @category Instances
 */
const sourcePackageEnvironment = ({
  environment,
  isConfigsPackage,
}: {
  readonly environment: string;
  readonly isConfigsPackage: boolean;
}): Type => {
  const base = {
    // Used by the tscheck script
    [tsConfigFilename]: TSCONFIG,
    // Used by the tsConfig file
    [tsConfigOthersFilename]: {
      ...TSCONFIG_OTHERS,
      // The others project of the configs package needs to import the source project for eslint.config.ts, prettier.config.ts, vitest.config.ts. See comment about TSCONFIG_TESTS for more details
      ...(isConfigsPackage ? { references: [{ path: tsConfigSrcFilename }] } : {}),
    },
    // Used by the tsConfig file
    [tsConfigExamplesFilename]: TSCONFIG_EXAMPLES,
    // Used by the tsConfig file
    [tsConfigTestsFilename]: TSCONFIG_TESTS,
  };

  if (environment === 'Browser')
    return make({
      ...base,
      // Used by the checks script
      [tsConfigSrcFilename]: TSCONFIG_BROWSER_SOURCE,
      // Used by the checks script
      // We don't use any dom specifities because it must run on the server. It's all hidden away in preact
      [eslintConfigFilename]: ESLINT_CONFIG_BROWSER_SOURCE,
    });

  if (environment === 'Node')
    return make({
      ...base,
      // Used by the checks script
      [tsConfigSrcFilename]: TSCONFIG_NODE_SOURCE,
      // Used by the checks script
      [eslintConfigFilename]: ESLINT_CONFIG_NODE_SOURCE,
    });

  if (environment === 'Plain')
    return make({
      ...base,
      // Used by the checks script
      [tsConfigSrcFilename]: TSCONFIG_PLAIN_SOURCE,
      // Used by the checks script
      [eslintConfigFilename]: ESLINT_CONFIG_PLAIN_SOURCE,
    });

  throw new Error(`Disallowed value for 'environment' parameter. Actual: '${environment}'`);
};

/**
 * ConfigFiles instance that creates the default exports part of a source package.
 *
 * @category Instances
 */
const baseSourcePackageExports: Type = make({
  [packageJsonFilename]: {
    exports: {
      '.': {
        default: `./${sourceFolderName}/${indexBareName}.js`,
      },
      './tests': {
        default: `./${sourceFolderName}/${testsIndexBaseName}.js`,
      },
    },
  },
});

/**
 * ConfigFiles instance that creates the exports part of a source package.
 *
 * @category Instances
 */
const sourcePackageExports = async ({
  path,
  packagePrefix,
  isConfigsPackage,
}: {
  readonly path: string;
  readonly packagePrefix: string | undefined;
  readonly isConfigsPackage: boolean;
}): Promise<Type> => {
  if (packagePrefix === undefined) return baseSourcePackageExports;

  const sourceFiles = (
    await readFilesRecursively({
      path: join(path, sourceFolderName),
      foldersToExclude: [internalFolderName, binariesFolderName],
      dontFailOnInexistentPath: false,
    })
  )
    .map((file) => ({
      ...file,
      isJavascript: allJavaScriptExtensions.includes(file.extension),
      isOther: allJsonExtensions.includes(file.extension),
    }))
    .filter(({ bareName, isJavascript, isOther }) => {
      const dotPos = bareName.indexOf('.');
      return (
        bareName.slice(0, dotPos === -1 ? undefined : dotPos) !== indexBareName
        && (isJavascript || isOther)
      );
    })
    .map(({ bareName, relativeParentPath, isJavascript, extension }) => {
      const barePath = fromOSPathToPosixPath(join(relativeParentPath, bareName));
      return {
        namespaceExportName: `${packagePrefix}${barePath
          .split(/[/.]/)
          .map(capitalizeFirstLetter)
          .join('')}`,
        barePath,
        isJavascript,
        extension,
      };
    });

  return sourceFiles.length === 0 ?
      baseSourcePackageExports
    : merge(
        baseSourcePackageExports,
        make({
          [indexTsPath]: sourceFiles
            .filter(({ isJavascript }) => isJavascript)
            // path.join removes upfront './' but typescript requires them so we must add them
            .map(
              ({ barePath, namespaceExportName }) =>
                `export * as ${namespaceExportName} from './${barePath}.js';`,
            )
            .join('\n'),
          [packageJsonFilename]: {
            exports: Object.fromEntries(
              sourceFiles.map(({ barePath, namespaceExportName, isJavascript, extension }) => {
                return [
                  `./${namespaceExportName}`,
                  {
                    /* We need to keep the original extensions for prettier that uses node with the `--experimental-transform-types` flag to read its configuration file when it has a `.ts` extension. Now node is unable to transform `.js` extensions into `.ts` extensions as TypeScript does */
                    default: `./${sourceFolderName}/${barePath}${isJavascript && !isConfigsPackage ? '.js' : extension}`,
                  },
                ] as const;
              }),
            ),
            scripts: {
              'update-imports': `node ${binariesPath}/update-imports.ts run ${packagePrefix}`,
              'auto-update-imports': `node ${binariesPath}/update-imports.ts watch ${packagePrefix}`,
            },
          },
        }),
      );
};

/**
 * ConfigFiles instance that implements the configs package specificities
 *
 * @category Instances
 */
const sourcePackageConfigsPackage = make({
  [packageJsonFilename]: {
    peerDependencies: configsPeerDependencies,
    dependencies: configsDependencies,
  },
});

/**
 * ConfigFiles instance that implements what is necessary in a package that has code (an esm
 * directory). This package is also a workspace
 */
/*
 * For a one-package repo, name and parentName are the same. For a sub package, name is the
 * name of the sub package and parentName the name of the monorepo that contains it.
 */
export const sourcePackage = async ({
  name,
  // parentName is equal to name in a one-package repo
  parentName = name,
  dependencies,
  devDependencies,
  peerDependencies,
  examples,
  buildMethod,
  environment,
  isPublished,
  hasDocGen,
  keywords,
  useEffectAsPeerDependency,
  useEffectPlatform,
  isConfigsPackage,
  path,
  packagePrefix,
}: {
  readonly name: string;
  readonly parentName?: string;
  readonly dependencies: StringRecord;
  readonly devDependencies: StringRecord;
  readonly peerDependencies: StringRecord;
  readonly examples: ReadonlyArray<string>;
  readonly buildMethod: string;
  readonly environment: string;
  readonly isPublished: boolean;
  readonly hasDocGen: boolean;
  readonly keywords: ReadonlyArray<string>;
  readonly useEffectAsPeerDependency: boolean;
  readonly useEffectPlatform: string;
  readonly isConfigsPackage: boolean;
  readonly path: string;
  readonly packagePrefix: string | undefined;
}): Promise<Type> => {
  const [finalDependencies, finalPeerDependencies] =
    useEffectAsPeerDependency ?
      [dependencies, { ...peerDependencies, ...effectDependencies }]
    : [{ ...dependencies, ...effectDependencies }, peerDependencies];

  return merge(
    make({
      // Used by the circular script
      [madgeConfigFilename]: MADGE_CONFIG,
      // Used by the test script
      [vitestConfigFilename]: VITEST_CONFIG_SOURCE(name),
      [packageJsonFilename]: {
        module: `./${sourceFolderName}/index.js`,
        ...(Object.keys(finalDependencies).length === 0 ? {} : { dependencies: finalDependencies }),
        ...(Object.keys(finalPeerDependencies).length === 0 ?
          {}
        : { peerDependencies: finalPeerDependencies }),
        devDependencies: {
          /* Include test-utils for tests except if the package is:
          - test-utils because it does not need to inclue itself
          - configs: to avoid circular dependencies
          */
          ...sourceDevDependencies,
          ...devDependencies,
        },
        scripts: {
          circular: `madge --extensions ts --circular --no-color --no-spinner ${sourceFolderName}`,
          'clean-prod': `pnpm rmrf ${prodFolderName} && pnpm mkdirp ${prodFolderName}`,
          checks: 'pnpm circular && pnpm tscheck && pnpm lint && pnpm test',
          tsconfig: `tsc --showConfig --project ${tsConfigSrcFilename}`,
          build: 'pnpm clean-prod && pnpm compile && cd ${prodFolderName} && pnpm i && cd ..',
          examples: examples
            .map((exampleName) => `${tsExecuter} ${examplesFolderName}/${exampleName}`)
            .join('&&'),
        },
        // Must be present even for private packages as it can be used for other purposes
        repository: {
          type: 'git',
          // Use git+https protocol as specified in npm documentation
          url: `git+https://${versionControlService}/${owner}/${parentName}.git`,
          ...(name === parentName ?
            {}
          : {
              directory: `${packagesFolderName}/${name}`,
            }),
        },
        // Must be present even for private packages as it can be used for instance by docgen
        homepage:
          // Use https protocol as specified in npm documentation
          `https://${versionControlService}/${owner}/${parentName}`
          + (name === parentName ? '' : `/tree/master/${packagesFolderName}/${name}`),
      },
    }),
    sourcePackageBuild({ buildMethod, isPublished }),
    sourcePackageVisibility({ parentName, isPublished, keywords }),
    sourcePackageDocGen({ hasDocGen }),
    sourcePackagePlatform({ useEffectPlatform }),
    sourcePackageEnvironment({ environment, isConfigsPackage }),
    isConfigsPackage ? sourcePackageConfigsPackage : empty,
    await sourcePackageExports({ path, packagePrefix, isConfigsPackage }),
  );
};

const repoVisibility: Type = make({
  /* Github actions need to be at the root of the github repo. This action calls a script `build-and-publish` but changes the working directory to the published package directory before calling them. So this script must be in sourcePackage.
   */
  [githubWorkflowsPublishPath]: GITHUB_WORKFLOWS_PUBLISH_SCRIPT,
});

/**
 * ConfigFiles instance that implements the docGen part of a repo
 *
 * @category Instances
 */
const repoDocGen = ({
  name,
  description,
}: {
  readonly name: string;
  readonly description: string;
}): Type =>
  make({
    /* Github actions need to be at the root of the github repo. This action calls a script `prepare-docs'`  */
    [githubWorkflowsPagesPath]: GITHUB_WORKFLOWS_PAGES_SCRIPT,
    // Used by the github pages.yml action
    [docsIndexMdPath]: description,
    // Used by the github pages.yml action
    [docsConfigYmlPath]: JUST_THE_DOCS_CONFIG(name),
    [packageJsonFilename]: {
      scripts: {
        // --if-present is necessary because it is possible that no package in the workspace has a docgen script
        'prepare-docs':
          'pnpm -r --if-present -include-workspace-root=true --parallel --aggregate-output docgen && compile-docs',
      },
    },
  });

/**
 * ConfigFiles instance that implements what is necessary at the root of a git (and github) repo
 *
 * @category Instances
 */
export const repo = ({
  name,
  description,
  hasDocGen,
  isPublished,
}: {
  readonly name: string;
  readonly description: string;
  readonly hasDocGen: boolean;
  readonly isPublished: boolean;
}): Type =>
  merge(
    ...[
      make({
        [gitIgnoreFilename]: GIT_IGNORE,
        [packageJsonFilename]: {
          packageManager,
          /*pnpm: {
      patchedDependencies: {},
      overrides: {
        //'tsconfig-paths': '^4.0.0'
      },
    },*/
        },
      }),
      ...(hasDocGen ? [repoDocGen({ name, description })] : []),
      ...(isPublished ? [repoVisibility] : []),
    ],
  );

/**
 * ConfigFiles instance that implements the workspace part of a top repo
 *
 * @category Instances
 */
export const topPackageWorkspace = ({
  name,
  allSourcePackagesNames,
  allPackagesPaths,
}: {
  readonly name: string;
  readonly allSourcePackagesNames: ReadonlyArray<string>;
  readonly allPackagesPaths: ReadonlyArray<string>;
}) =>
  make({
    [pnpmWorkspaceFilename]:
      PNPM_WORKSPACE_CONFIG
      + (allSourcePackagesNames.length !== 0 ?
        `
overrides:
${allSourcePackagesNames.map((packageName) => `  '${slashedScope}${packageName}': 'workspace:*'`).join('\n')}`
      : ''),
    // Used by vscode
    [`${name}.code-workspace`]: VSCODE_WORKSPACE_CONFIG({
      name,
      allPackagesPaths,
    }),
  });
