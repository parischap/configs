/**
 * This module represents an object whose keys are the names of the configuration files of a package
 * and the values the contents of these files
 */
/* This module must not import any external dependency. It must be runnable without a package.json because it is used by the generate-config-files.ts bin */
import { mkdir, readFile, writeFile } from 'node:fs/promises';
import { dirname, join, parse } from 'node:path';
import {
  autoGeneratedFileWarning,
  baseDevDependencies,
  binariesFolderName,
  binariesPath,
  configsDependencies,
  configsPackageName,
  configsPeerDependencies,
  docgenConfigFilename,
  docGenDependencies,
  docsConfigYmlPath,
  docsIndexMdPath,
  effectDependencies,
  effectPlatformDependencies,
  examplesFolderName,
  formatterConfigFilename,
  formatterIgnoreFilename,
  githubWorkflowsPagesPath,
  githubWorkflowsPublishPath,
  gitIgnoreFilename,
  indexBareName,
  indexTsPath,
  internalFolderName,
  javaScriptExtensions,
  jsoncExtensions,
  jsonExtensions,
  linterConfigFilename,
  madgeConfigFilename,
  owner,
  packageJsonFilename,
  packageManager,
  packagesFolderName,
  pnpmWorkspaceFilename,
  prodFolderName,
  projectConfigFilename,
  slashedScope,
  sourceDevDependencies,
  sourceFolderName,
  testsIndexBaseName,
  tsConfigBaseFilename,
  tsConfigDocGenFilename,
  tsConfigExamplesFilename,
  tsConfigFilename,
  tsConfigOthersFilename,
  tsConfigSrcFilename,
  tsConfigTestsFilename,
  tsExecuter,
  versionControlService,
  vitestConfigFilename,
  ymlExtensions,
} from '../shared-utils/constants.js';
import {
  capitalizeFirstLetter,
  deepMerge2,
  fromOSPathToPosixPath,
  isRecord,
  objectToYaml,
  prettyStringify,
  readFilesRecursively,
  type Data,
  type ReadonlyRecord,
  type StringRecord,
} from '../shared-utils/utils.js';
import Docgen from './templates/docgen.template.js';
import DocsConfig from './templates/docs/_config.template.js';
import EslintConfigNode from './templates/eslint.config.node.template.js';
import EslintConfigPlain from './templates/eslint.config.plain.template.js';
import GithubWorkflowsPages from './templates/github/workflows/pages.template.js';
import GithubWorkflowsPublish from './templates/github/workflows/publish.template.js';
import GitIgnore from './templates/gitignore.template.js';
import MadgeConfig from './templates/madgerc.template.js';
import PnpmWorkspace from './templates/pnpm-workspace.template.js';
import FormatterIgnore from './templates/prettierignore.template.js';
import FormatterConfig from './templates/prettierrc.template.js';
import TsconfigBase from './templates/tsconfig.base.template.js';
import TsconfigDocgen from './templates/tsconfig.docgen.template.js';
import TsconfigExamples from './templates/tsconfig.examples.template.js';
import TsconfigOthers from './templates/tsconfig.others.template.js';
import TsconfigPlain from './templates/tsconfig.plain.template.js';
import TsconfigSource from './templates/tsconfig.source.template.js';
import Tsconfig from './templates/tsconfig.template.js';
import TsconfigTests from './templates/tsconfig.tests.template.js';
import VitestConfigNoSource from './templates/vitest.config.nosource.template.js';
import VitestConfigSource from './templates/vitest.config.source.template.js';
import VscodeWorkspace from './templates/vscode-workspace.template.js';

/**
 * Module tag
 *
 * @category Models
 */
export const moduleTag = '@parischap/configs/internal/bin-utils/ConfigFiles/';
const _TypeId: unique symbol = Symbol.for(moduleTag) as _TypeId;
type _TypeId = typeof _TypeId;

const TsconfigBrowser = TsconfigPlain;
const TsconfigNode = TsconfigSource;

/**
 * Type of a ConfigFiles
 *
 * @category Models
 */
export class Type {
  /**
   * Record of all the configuration files of a package. The keys are the names of the configuration
   * files and the values the contents of these files. If the key has a `json` extension, the
   * associated value is converted to a json string with JSON.stringify unless it is already a
   * string. Otherwise, the associated value is a string.
   */
  readonly configurationFiles: ReadonlyRecord<string, unknown>;

  /** Class constructor */
  private constructor(params: Data<Type>) {
    this.configurationFiles = params.configurationFiles;
  }

  /** Static constructor */
  static make(configurationFiles: ReadonlyRecord): Type {
    return new Type({ configurationFiles });
  }

  /** @internal */
  get [_TypeId](): _TypeId {
    return _TypeId;
  }
}

/**
 * Constructor
 *
 * @category Constructors
 */
export const make = (configurationFiles: ReadonlyRecord): Type => Type.make(configurationFiles);

/**
 * Returns the value of the `configurationFiles` property of `self`
 *
 * @category Destructors
 */
export const configurationFiles = (self: Type): ReadonlyRecord<string, unknown> =>
  self.configurationFiles;

/**
 * Returns a copy of `self` in which only exports configuration files have been kept
 *
 * @category Destructors
 */
export const filterExportsFiles = (self: Type): Type =>
  make(
    Object.fromEntries(
      Object.entries(self.configurationFiles).filter(
        ([filename]) => filename === indexTsPath || filename === packageJsonFilename,
      ),
    ),
  );

/**
 * Builds a new Packagefiles from the concatenation of several ConfigFiles
 *
 * @category Constructors
 */
export const merge = (...packageFilesArr: ReadonlyArray<Type>): Type =>
  make(
    packageFilesArr.reduce(
      (acc, packageFile) => deepMerge2(acc, packageFile.configurationFiles),
      {},
    ),
  );

/**
 * Saves `self` at path `path`
 *
 * @category Destructors
 */
export const save =
  ({ packagePath, packageName }: { readonly packagePath: string; readonly packageName: string }) =>
  (self: Type) =>
    Promise.all(
      Object.entries(self.configurationFiles).map(async ([filename, fileContent]) => {
        const { ext, base } = parse(filename);
        const isYml = ymlExtensions.includes(ext);
        const contentToWriteFunc =
          typeof fileContent === 'string' ? () => fileContent
          : jsonExtensions.includes(ext) || base === madgeConfigFilename ?
            () => prettyStringify(fileContent)
          : isRecord(fileContent) && isYml ?
            () => objectToYaml({ value: fileContent, errorPrefix: '' }).join('\n')
          : () => {
              throw new Error(
                `Entry '${filename}' in '${projectConfigFilename}' must have value of type string`,
              );
            };

        const targetFilename = join(packagePath, filename);
        // Create directory in case it does not exist
        /* eslint-disable-next-line functional/no-expression-statements*/
        await mkdir(dirname(targetFilename), { recursive: true });
        console.log(`'${packageName}': Saving configuration file '${filename}'`);

        const commentType =
          isYml || filename === formatterIgnoreFilename || filename === gitIgnoreFilename ? 'Hashed'
          : jsoncExtensions.includes(ext) ? 'Slashed'
          : 'NotSupported';

        if (commentType === 'NotSupported')
          /* eslint-disable-next-line functional/no-expression-statements*/
          await writeFile(targetFilename, contentToWriteFunc());
        else {
          const autoGeneratedComment =
            (commentType === 'Hashed' ? '#' : '//') + autoGeneratedFileWarning;
          let exists = true;
          let contents = '';
          try {
            /* eslint-disable-next-line functional/no-expression-statements */
            contents = await readFile(targetFilename, 'utf8');
          } catch (e: unknown) {
            if (e instanceof Error && 'code' in e && e['code'] === 'ENOENT')
              /* eslint-disable-next-line functional/no-expression-statements */
              exists = false;
            else throw e;
          }

          if (!exists || contents.startsWith(autoGeneratedComment)) {
            /* eslint-disable-next-line functional/no-expression-statements */
            await writeFile(targetFilename, autoGeneratedComment + contentToWriteFunc());
          } else
            throw new Error(`Could not autogenerate '${targetFilename}' because the file already exists \
and does not start with predefined warning comment`);
        }
      }),
    );

/** Empty ConfigFiles instance */
export const empty = make({});

/**
 * ConfigFiles instance that implements what is necessary in all situations
 *
 * @category Instances
 */
export const anyPackage = ({
  name,
  description,
  scripts = {},
}: {
  readonly name: string;
  readonly description: string;
  readonly scripts?: StringRecord;
}): Type =>
  make({
    // Used by the format script
    [formatterConfigFilename]: FormatterConfig,
    // Used by the format script
    [formatterIgnoreFilename]: FormatterIgnore,
    [tsConfigBaseFilename]: TsconfigBase,
    [packageJsonFilename]: {
      name: `${slashedScope}${name}`,
      description,
      // Needs to be present even at the top or root of a monorepo because there are some javascript config files
      type: 'module',
      author: 'Jérôme MARTIN',
      license: 'MIT',
      scripts: {
        // tests can be run at all levels, even at non project levels because there are vitest projects
        test: 'vitest run',
        tscheck: `tsgo -b ${tsConfigFilename} --force`,
        lint: 'eslint .',
        //'lint-and-analyze': 'eslint . --stats -f json > eslint-stats.json',
        //'lint-rules': 'pnpx @eslint/config-inspector',
        format: 'prettier .',
        'clean-config-files': `${tsExecuter} ${binariesPath}/clean-config-files.ts -activePackageOnly`,
        'clean-node-modules': `${tsExecuter} ${binariesPath}/clean-node-modules.ts -activePackageOnly`,
        'clean-prod': `${tsExecuter} ${binariesPath}/clean-prod.ts -activePackageOnly`,
        'generate-config-files': `${tsExecuter} ${binariesPath}/generate-config-files.ts -activePackageOnly`,
        'clean-all-config-files': `${tsExecuter} ${binariesPath}/clean-config-files.ts`,
        'clean-all-node-modules': `${tsExecuter} ${binariesPath}/clean-node-modules.ts`,
        'clean-all-prod': `${tsExecuter} ${binariesPath}/clean-prod.ts`,
        'generate-all-config-files': `${tsExecuter} ${binariesPath}/generate-config-files.ts`,
        'update-all-exports': `${tsExecuter} ${binariesPath}/update-exports.ts`,
        'watch-all-for-exports': `${tsExecuter} ${binariesPath}/update-exports.ts -watch`,
        'reinstall-all-dependencies': 'pnpm i --force',
        ...scripts,
      },
      devDependencies: {
        /* Even configs needs to import itself so script can be written homogeneously in all packages */
        [`${slashedScope}${configsPackageName}`]: `git+ssh://${versionControlService}/${owner}/${configsPackageName}`,
        ...baseDevDependencies,
      },
    },
  });

/**
 * ConfigFiles instance that implements what is necessary in a package that has no code (no esm
 * directory). Such a package is also a workspace.
 *
 * @category Instances
 */
export const noSourcePackage: Type = make({
  // Used by the checks script
  [tsConfigFilename]: TsconfigOthers,
  // Used by the checks script
  [linterConfigFilename]: EslintConfigPlain,
  // Used by the test script
  [vitestConfigFilename]: VitestConfigNoSource,
  [packageJsonFilename]: {
    scripts: {
      checks: 'pnpm tscheck && pnpm lint',
      // --if-present is necessary because it is possible that no package in the workspace has a build script
      'build-all': 'pnpm --if-present -r build',
      // --if-present is necessary because it is possible that no package in the workspace has an auto-update-imports script
      'tscheck-all': 'pnpm -r -include-workspace-root=true tscheck',
      'lint-all': 'pnpm -r -include-workspace-root=true lint',
      'checks-all': 'pnpm -r -include-workspace-root=true checks',
      'format-all': 'pnpm -r -include-workspace-root=true format',
    },

    /*pnpm: {
        patchedDependencies: {},
        overrides: {
          //'tsconfig-paths': '^4.0.0'
        },
      },*/
  },
});

/**
 * ConfigFiles instance that creates the build part of a source package.
 *
 * @category Instances
 */
const sourcePackageBuild = ({
  buildMethod,
  isPublished,
}: {
  readonly buildMethod: string;
  readonly isPublished: boolean;
}): Type => {
  if (buildMethod === 'None') return make({});

  if (
    buildMethod === 'NoBundling'
    || buildMethod === 'LightBundling'
    || buildMethod === 'DeepBundling'
  )
    return make({
      [packageJsonFilename]: {
        sideEffects: [],
        scripts: {
          compile: 'vite build',
          // tsc builds but also generate types. All my packages ship with the sideEffects-free key in package.json. And this is perfectly well understood by vite and rollup. So annotate-pure-calls is only necessary for published packages that might be used by clients who use old bundlers. As far as I am concerned, I do not need cjs code. Likewise, this is only necessary for published packages.
          /*`tsc -b ${tsConfigSrcFilename} --force`
            + (isPublished ?
              ` && babel ${prodFolderName}/${sourceFolderName} --out-dir ${prodFolderName}/${commonJsFolderName}`
              + '--plugins @babel/transform-export-namespace-from --plugins @babel/transform-modules-commonjs  --source-maps'
            : '')
            + ` && babel ${prodFolderName} --plugins annotate-pure-calls --out-dir ${prodFolderName} --source-maps`
            + ' && pnpm prodify-lib',*/
        },
      },
    });

  // 'BundleWithDeps' , 'AppClient'
  throw new Error(`Disallowed value for 'buildMethod' parameter. Actual: '${buildMethod}'`);
};

/**
 * ConfigFiles instance that creates the visibility part of a source package.
 *
 * @category Instances
 */
const sourcePackageVisibility = ({
  parentName,
  isPublished,
  keywords,
}: {
  readonly parentName: string;
  readonly isPublished: boolean;
  readonly keywords: ReadonlyArray<string>;
}): Type =>
  make(
    isPublished ?
      {
        [packageJsonFilename]: {
          bugs: {
            url: `https://github.com/${owner}/${parentName}/issues`,
          },
          funding: [
            {
              type: 'ko-fi',
              url: 'https://ko-fi.com/parischap',
            },
          ],
          // Put specific keywords in first position so important keywords come out first
          keywords: [...keywords, 'effect', 'typescript', 'functional-programming'],
          scripts: {
            // Called by the publish github action defined in configInternalRepo.ts/
            'build-and-publish': 'pnpm build && pnpm checks && pnpm publish-to-npm',
            // npm publish ./dist --access=public does not work
            'publish-to-npm': `cd ${prodFolderName} && npm publish --access=public && cd ..`,
          },
        },
      }
    : {
        [packageJsonFilename]: {
          private: true,
        },
      },
  );

/**
 * ConfigFiles instance that creates the doc generation part of a source package.
 *
 * @category Instances
 */
const sourcePackageDocGen = ({ hasDocGen }: { readonly hasDocGen: boolean }): Type =>
  make(
    hasDocGen ?
      {
        [packageJsonFilename]: {
          scripts: {
            docgen: 'docgen',
          },
          devDependencies: docGenDependencies,
        },
        [tsConfigDocGenFilename]: TsconfigDocgen,
        [docgenConfigFilename]: Docgen,
      }
    : {},
  );

/**
 * ConfigFiles instance that creates the Effect Platform part of a source package.
 *
 * @category Instances
 */
const sourcePackagePlatform = ({
  useEffectPlatform,
}: {
  readonly useEffectPlatform: string;
}): Type => {
  if (useEffectPlatform === 'No') return make({});

  if (useEffectPlatform === 'AsDependency')
    return make({
      [packageJsonFilename]: {
        dependencies: effectPlatformDependencies,
      },
    });

  if (useEffectPlatform === 'AsPeerDependency')
    return make({
      [packageJsonFilename]: {
        peerDependencies: effectPlatformDependencies,
      },
    });

  throw new Error(
    `Disallowed value for 'useEffectPlatform' parameter. Actual: '${useEffectPlatform}'`,
  );
};

/**
 * ConfigFiles instance that creates the Environment part of a source package.
 *
 * @category Instances
 */
const sourcePackageEnvironment = ({
  environment,
  isConfigsPackage,
}: {
  readonly environment: string;
  readonly isConfigsPackage: boolean;
}): Type => {
  const base = {
    // Used by the tscheck script
    [tsConfigFilename]: Tsconfig,
    // Used by the tsConfig file
    [tsConfigOthersFilename]: {
      ...TsconfigOthers,
      // The others project of the configs package needs to import the source project for vitest.config.ts
      ...(isConfigsPackage ? { references: [{ path: tsConfigSrcFilename }] } : {}),
    },
    // Used by the tsConfig file
    [tsConfigExamplesFilename]: TsconfigExamples,
    // Used by the tsConfig file
    [tsConfigTestsFilename]: TsconfigTests,
  };

  if (environment === 'Browser')
    return make({
      ...base,
      // Used by the checks script
      [tsConfigSrcFilename]: TsconfigBrowser,
      // Used by the checks script
      // We don't use any dom specifities because it must run on the server. It's all hidden away in preact
      [linterConfigFilename]: EslintConfigPlain,
    });

  if (environment === 'Node')
    return make({
      ...base,
      // Used by the checks script
      [tsConfigSrcFilename]: TsconfigNode,
      // Used by the checks script
      [linterConfigFilename]: EslintConfigNode,
    });

  if (environment === 'Plain')
    return make({
      ...base,
      // Used by the checks script
      [tsConfigSrcFilename]: TsconfigPlain,
      // Used by the checks script
      [linterConfigFilename]: EslintConfigPlain,
    });

  throw new Error(`Disallowed value for 'environment' parameter. Actual: '${environment}'`);
};

/**
 * ConfigFiles instance that creates the default exports part of a source package.
 *
 * @category Instances
 */
const baseSourcePackageExports: Type = make({
  [packageJsonFilename]: {
    exports: {
      '.': {
        default: `./${sourceFolderName}/${indexBareName}.js`,
      },
      './tests': {
        default: `./${sourceFolderName}/${testsIndexBaseName}.js`,
      },
    },
  },
});

/**
 * ConfigFiles instance that creates the exports part of a source package.
 *
 * @category Instances
 */
const sourcePackageExports = async ({
  path,
  packagePrefix,
  buildMethod,
}: {
  readonly path: string;
  readonly packagePrefix: string | undefined;
  readonly buildMethod: string;
}): Promise<Type> => {
  if (packagePrefix === undefined) return baseSourcePackageExports;

  const sourceFiles = (
    await readFilesRecursively({
      path: join(path, sourceFolderName),
      foldersToExclude: [internalFolderName, binariesFolderName],
      dontFailOnInexistentPath: false,
    })
  )
    .map((file) => ({
      ...file,
      isJavascript: javaScriptExtensions.includes(file.extension),
      isOther: jsonExtensions.includes(file.extension),
    }))
    .filter(({ bareName, isJavascript, isOther }) => {
      const dotPos = bareName.indexOf('.');
      return (
        bareName.slice(0, dotPos === -1 ? undefined : dotPos) !== indexBareName
        && (isJavascript || isOther)
      );
    })
    .map(({ bareName, relativeParentPath, isJavascript, extension }) => {
      const barePath = fromOSPathToPosixPath(join(relativeParentPath, bareName));
      return {
        namespaceExportName: `${packagePrefix}${barePath
          .split(/[/.]/)
          .map(capitalizeFirstLetter)
          .join('')}`,
        barePath,
        isJavascript,
        extension,
      };
    });

  return sourceFiles.length === 0 ?
      baseSourcePackageExports
    : merge(
        baseSourcePackageExports,
        make({
          [indexTsPath]: sourceFiles
            .filter(({ isJavascript }) => isJavascript)
            // path.join removes upfront './' but typescript requires them so we must add them
            .map(
              ({ barePath, namespaceExportName }) =>
                `export * as ${namespaceExportName} from './${barePath}.js';`,
            )
            .join('\n'),
          [packageJsonFilename]: {
            exports: Object.fromEntries(
              sourceFiles.map(
                ({ barePath, namespaceExportName, isJavascript, extension }) =>
                  [
                    `./${namespaceExportName}`,
                    {
                      /* If possible, use a `.js` extension so it does not need to be changed after the build. However, this is not useful for a package that does not need building. In particular, we need to keep the original extensions for prettier that uses node with the `--experimental-transform-types` flag to read its configuration file because node is unable to transform `.js` extensions into `.ts` extensions. Same for vite configuration files */
                      default: `./${sourceFolderName}/${barePath}${isJavascript && buildMethod !== 'None' ? '.js' : extension}`,
                    },
                  ] as const,
              ),
            ),
          },
        }),
      );
};

/**
 * ConfigFiles instance that implements the configs package specificities
 *
 * @category Instances
 */
const sourcePackageConfigsPackage = make({
  [packageJsonFilename]: {
    peerDependencies: configsPeerDependencies,
    dependencies: configsDependencies,
  },
});

/**
 * ConfigFiles instance that implements what is necessary in a package that has code (an esm
 * directory). This package is also a workspace
 */
/*
 * For a one-package repo, name and parentName are the same. For a sub package, name is the
 * name of the sub package and parentName the name of the monorepo that contains it.
 */
export const sourcePackage = async ({
  name,
  // parentName is equal to name in a one-package repo
  parentName = name,
  dependencies,
  devDependencies,
  peerDependencies,
  examples,
  buildMethod,
  environment,
  isPublished,
  hasDocGen,
  keywords,
  useEffectAsPeerDependency,
  useEffectPlatform,
  isConfigsPackage,
  path,
  packagePrefix,
}: {
  readonly name: string;
  readonly parentName?: string;
  readonly dependencies: StringRecord;
  readonly devDependencies: StringRecord;
  readonly peerDependencies: StringRecord;
  readonly examples: ReadonlyArray<string>;
  readonly buildMethod: string;
  readonly environment: string;
  readonly isPublished: boolean;
  readonly hasDocGen: boolean;
  readonly keywords: ReadonlyArray<string>;
  readonly useEffectAsPeerDependency: boolean;
  readonly useEffectPlatform: string;
  readonly isConfigsPackage: boolean;
  readonly path: string;
  readonly packagePrefix: string | undefined;
}): Promise<Type> => {
  const [finalDependencies, finalPeerDependencies] =
    useEffectAsPeerDependency ?
      [dependencies, { ...peerDependencies, ...effectDependencies }]
    : [{ ...dependencies, ...effectDependencies }, peerDependencies];

  return merge(
    make({
      // Used by the circular script
      [madgeConfigFilename]: MadgeConfig,
      // Used by the test script
      [vitestConfigFilename]: VitestConfigSource,
      [packageJsonFilename]: {
        module: `./${sourceFolderName}/index.js`,
        ...(Object.keys(finalDependencies).length === 0 ? {} : { dependencies: finalDependencies }),
        ...(Object.keys(finalPeerDependencies).length === 0 ?
          {}
        : { peerDependencies: finalPeerDependencies }),
        devDependencies: {
          /* Include test-utils for tests except if the package is:
          - test-utils because it does not need to inclue itself
          - configs: to avoid circular dependencies
          */
          ...sourceDevDependencies,
          ...devDependencies,
        },
        scripts: {
          circular: `madge --extensions ts --circular --no-color --no-spinner ${sourceFolderName}`,
          'clean-prod': `pnpm rmrf ${prodFolderName} && pnpm mkdirp ${prodFolderName}`,
          checks: 'pnpm circular && pnpm tscheck && pnpm lint && pnpm test',
          tsconfig: `tsc --showConfig --project ${tsConfigSrcFilename}`,
          build: `pnpm clean-prod && pnpm compile && cd ${prodFolderName} && pnpm i && cd ..`,
          examples: examples
            .map((exampleName) => `${tsExecuter} ${examplesFolderName}/${exampleName}`)
            .join('&&'),
          'update-exports': `${tsExecuter} ${binariesPath}/update-exports.ts -activePackageOnly`,
          'watch-for-exports': `${tsExecuter} ${binariesPath}/update-exports.ts -watch -activePackageOnly`,
        },
        // Must be present even for private packages as it can be used for other purposes
        repository: {
          type: 'git',
          // Use git+https protocol as specified in npm documentation
          url: `git+https://${versionControlService}/${owner}/${parentName}.git`,
          ...(name === parentName ?
            {}
          : {
              directory: `${packagesFolderName}/${name}`,
            }),
        },
        // Must be present even for private packages as it can be used for instance by docgen
        homepage:
          // Use https protocol as specified in npm documentation
          `https://${versionControlService}/${owner}/${parentName}`
          + (name === parentName ? '' : `/tree/master/${packagesFolderName}/${name}`),
      },
    }),
    sourcePackageBuild({ buildMethod, isPublished }),
    sourcePackageVisibility({ parentName, isPublished, keywords }),
    sourcePackageDocGen({ hasDocGen }),
    sourcePackagePlatform({ useEffectPlatform }),
    sourcePackageEnvironment({ environment, isConfigsPackage }),
    isConfigsPackage ? sourcePackageConfigsPackage : empty,
    await sourcePackageExports({ path, packagePrefix, buildMethod }),
  );
};

const repoVisibility: Type = make({
  /* Github actions need to be at the root of the github repo. This action calls a script `build-and-publish` but changes the working directory to the published package directory before calling them. So this script must be in sourcePackage.
   */
  [githubWorkflowsPublishPath]: GithubWorkflowsPublish,
});

/**
 * ConfigFiles instance that implements the docGen part of a repo
 *
 * @category Instances
 */
const repoDocGen = ({
  name,
  description,
}: {
  readonly name: string;
  readonly description: string;
}): Type =>
  make({
    /* Github actions need to be at the root of the github repo. This action calls a script `prepare-docs'`  */
    [githubWorkflowsPagesPath]: GithubWorkflowsPages,
    // Used by the github pages.yml action
    [docsIndexMdPath]: description,
    // Used by the github pages.yml action
    [docsConfigYmlPath]: DocsConfig({ name }),
    [packageJsonFilename]: {
      scripts: {
        // --if-present is necessary because it is possible that no package in the workspace has a docgen script
        'prepare-docs':
          'pnpm -r --if-present -include-workspace-root=true --parallel --aggregate-output docgen && compile-docs',
      },
    },
  });

/**
 * ConfigFiles instance that implements what is necessary at the root of a git (and github) repo
 *
 * @category Instances
 */
export const repo = ({
  name,
  description,
  hasDocGen,
  isPublished,
}: {
  readonly name: string;
  readonly description: string;
  readonly hasDocGen: boolean;
  readonly isPublished: boolean;
}): Type =>
  merge(
    ...[
      make({
        [gitIgnoreFilename]: GitIgnore,
      }),
      ...(hasDocGen ? [repoDocGen({ name, description })] : []),
      ...(isPublished ? [repoVisibility] : []),
    ],
  );

/**
 * ConfigFiles instance that implements the workspace part of a top repo
 *
 * @category Instances
 */
export const top = ({
  name,
  allSourcePackagesNames,
  allPackagesPaths,
}: {
  readonly name: string;
  readonly allSourcePackagesNames: ReadonlyArray<string>;
  readonly allPackagesPaths: ReadonlyArray<string>;
}) =>
  make({
    [pnpmWorkspaceFilename]: PnpmWorkspace({ allSourcePackagesNames }),
    // Used by vscode
    [`${name}.code-workspace`]: VscodeWorkspace({
      allPackagesPaths,
    }),
    [packageJsonFilename]: {
      packageManager,
      /*pnpm: {
      patchedDependencies: {},
      overrides: {
        //'tsconfig-paths': '^4.0.0'
      },
    },*/
    },
  });
