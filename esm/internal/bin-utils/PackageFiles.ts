/**
 * This module represents an object whose keys are the names of the configuration files of a package
 * and the values the contents of these files
 */
/* This module must not import any external dependency. It must be runnable without a package.json because it is used by the generate-config-files.ts bin */
import { readFileSync } from 'node:fs';
import { mkdir } from 'node:fs/promises';
import { dirname, extname, join } from 'node:path';
import {
  allFilesPattern,
  allTsFiles,
  baseDevDependencies,
  binariesPath,
  commonJsFolderName,
  configFilename,
  configsPackageName,
  configsPeerDependencies,
  docgenConfigFilename,
  docGenDependencies,
  docsConfigYmlFilename,
  docsFolderName,
  docsIndexMdFilename,
  effectDependencies,
  effectPlatformDependencies,
  eslintConfigFilename,
  examplesFolderName,
  examplesMark,
  filesGeneratedByThirdParties,
  foldersGeneratedByThirdParties,
  foldersWithoutConfigFiles,
  githubFolderName,
  githubWorkflowsPagesFilename,
  githubWorkflowsPublishFilename,
  gitIgnoreFilename,
  indexTsFilename,
  internalFolderName,
  madgeConfigFilename,
  npmFolderName,
  othersFolderName,
  othersMark,
  owner,
  packageJsonFilename,
  packageManager,
  packagesFolderName,
  pnpmWorkspaceFilename,
  prettierConfigFilename,
  prettierIgnoreFilename,
  prodFolderName,
  slashedScope,
  sourceDevDependencies,
  sourceFolderName,
  srcMark,
  testsFolderName,
  testsMark,
  tsBuildInfoFolderName,
  tsConfigBaseFilename,
  tsConfigDocGenFilename,
  tsConfigExamplesFilename,
  tsConfigFilename,
  tsConfigOthersFilename,
  tsConfigSrcFilename,
  tsConfigStyleIncludeForExampleFiles,
  tsConfigStyleIncludeForSourceFiles,
  tsConfigStyleIncludeForTestsFiles,
  tsConfigTestsFilename,
  tsExecuter,
  typesFolderName,
  versionControlService,
  viteConfigFilename,
  vitestConfigFilename,
  workflowsFolderName,
} from '../shared-utils/constants.js';
import type { ReadonlyRecord, StringArray, StringRecord } from '../shared-utils/types.js';
import { deepMerge, prettyStringify, writeAutogeneratedFile } from '../shared-utils/utils.js';
import type * as Package from './Package.js';

/**
 * Module tag
 *
 * @category Module markers
 */
const _moduleTag = '@parischap/configs/internal/bin-utils/PackageFiles/';
const _TypeId: unique symbol = Symbol.for(_moduleTag) as _TypeId;
type _TypeId = typeof _TypeId;

/**
 * Type of a PackageFiles
 *
 * @category Models
 */
export interface Type {
  /**
   * Record of all the configuration files of a package. The keys are the names of the configuration
   * files and the values the contents of these files. If the key has a `json` extension, the
   * associated value is converted to a json string with JSON.stringfy unless it is already a
   * string. Otherwise, the associated value must be a string.
   */
  readonly configurationFiles: ReadonlyRecord;
  /** Package whose configuration files are described by self */
  readonly linkedPackage: Package.Type;
  /** @internal */
  readonly [_TypeId]: _TypeId;
}

/**
 * Type guard
 *
 * @category Guards
 */
export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

/** _prototype */
const _proto = {
  [_TypeId]: _TypeId,
};

/**
 * Parameters used to build a PackageFiles for a source package
 *
 * @category Models
 */
export interface SourcePackagesPackageFilesParameters {
  readonly name: string;
  readonly description: string;
  readonly dependencies: Readonly<StringRecord>;
  readonly devDependencies: Readonly<StringRecord>;
  readonly peerDependencies: Readonly<StringRecord>;
  readonly examples: Readonly<StringArray>;
  readonly scripts: Readonly<StringRecord>;
  readonly environment: string;
  readonly buildMethod: string;
  readonly isPublished: boolean;
  readonly hasDocGen: boolean;
  readonly keywords: Readonly<StringArray>;
  readonly useEffectAsPeerDependency: boolean;
  readonly useEffectPlatform: string;
  readonly packagePrefix: string | undefined;
  readonly indexTsContents: string;
  readonly packageJsonExports: ReadonlyRecord;
}

const PRETTIER_CONFIG = `import {config} from '@parischap/configs/PrettierConfig';
export default config`;

const PRETTIER_IGNORE: string = [
  ...foldersGeneratedByThirdParties.map((folderName) => `/${folderName}/`),
  ...filesGeneratedByThirdParties.map((fileName) => `/${fileName}`),
].join('\n');

const ESLINT_CONFIG_BROWSER_SOURCE = `import {browserEslintConfig} from '@parischap/configs/EslintConfig';
export default browserEslintConfig({tsconfigRootDir:import.meta.dirname})`;

const ESLINT_CONFIG_NODE_SOURCE = `import {nodeEslintConfig} from '@parischap/configs/EslintConfig';
export default nodeEslintConfig({tsconfigRootDir:import.meta.dirname})`;

const ESLINT_CONFIG_PLAIN_SOURCE = `import {plainEslintConfig} from '@parischap/configs/EslintConfig';
export default plainEslintConfig({tsconfigRootDir:import.meta.dirname})`;

const ESLINT_CONFIG_OTHERS = `import {plainEslintConfig} from '@parischap/configs/EslintConfig';
export default plainEslintConfig({tsconfigRootDir:import.meta.dirname})`;

const TSCONFIG_BASE = readFileSync(join(import.meta.dirname, 'assets/tsconfigBase.json'), 'utf8');

/* General tsconfig.json file. It references four sub-projects, each with its own environments (node available or not):
- the source sub-project where the package modules are located.
- the examples sub-project where example modules are located. The examples sub-project will usually use the node environment. Even if the examples sub-project has the exact same configuration as the source sub-project, they must be seperated because building the source project can always be necessary.
- the tests sub-project where test modules are located. The tests sub-project will usually use the node environment. Even if the tests sub-project has the exact same configuration as the source sub-project, they must be seperated because building the source project can always be necessary.
- the others sub-project which covers all configuration modules (eslint.config.ts, prettier.config.ts, vitest.config.ts,...). The others sub-project uses the node environment.
*/
const TSCONFIG: ReadonlyRecord = {
  include: [],
  references: [
    { path: tsConfigSrcFilename },
    { path: tsConfigExamplesFilename },
    { path: tsConfigTestsFilename },
    { path: tsConfigOthersFilename },
  ],
};

const TSCONFIG_SOURCE = {
  extends: './tsconfig.base.json',
  include: [tsConfigStyleIncludeForSourceFiles],
  /* NoEmit cannot be set to true in a referenced project even though we never emit anything . rootDir, outDir and declarationDir need to be set otherwise Typescript will complain */
  compilerOptions: {
    tsBuildInfoFile: `${tsBuildInfoFolderName}/${srcMark}.tsbuildinfo`,
    rootDir: '.',
    outDir: prodFolderName,
    declarationDir: `${prodFolderName}/${typesFolderName}`,
    // For some reason, Typescript needs to Emit declarations of this project referenced by the tests and examples projects
    noEmit: false,
    emitDeclarationOnly: true,
    //declarationMap: true,
  },
};

const TSCONFIG_BROWSER_SOURCE: ReadonlyRecord = deepMerge(TSCONFIG_SOURCE, {
  compilerOptions: {
    types: [],
    /* We don't use any dom specifities in our client code because it must runnable on the server. DOM manipulation is taken care of by preact */
    //lib: ['DOM', 'DOM.Iterable'],
  },
});

const TSCONFIG_NODE_SOURCE: ReadonlyRecord = TSCONFIG_SOURCE;

const TSCONFIG_PLAIN_SOURCE: ReadonlyRecord = deepMerge(TSCONFIG_SOURCE, {
  compilerOptions: {
    types: [],
  },
});

/*
Although node allows importing a package from itself (see https://nodejs.org/api/packages.html#self-referencing-a-package-using-its-name), it does not work well with Typescript because it will not consider the imported package as a seperate one. In particular, it will complain that the imported file is not defined in the include field of the tsconfig.json. For that reason, we need to reference the source sub-project from the examples sub-project 
 */
const TSCONFIG_EXAMPLES: ReadonlyRecord = {
  extends: './tsconfig.base.json',
  include: [tsConfigStyleIncludeForExampleFiles],
  references: [{ path: tsConfigSrcFilename }],
  /* NoEmit cannot be set to true in a referenced project even though we never emit anything . rootDir, outDir and declarationDir need to be set otherwise Typescript will complain */
  compilerOptions: {
    tsBuildInfoFile: `.tsbuildinfo/${examplesMark}.tsbuildinfo`,
    rootDir: '.',
    outDir: prodFolderName,
    declarationDir: `${prodFolderName}/${examplesFolderName}/${typesFolderName}`,
    //declarationMap: true
  },
};

/*
Although node allows importing a package from itself (see https://nodejs.org/api/packages.html#self-referencing-a-package-using-its-name), it does not work well with Typescript because it will not consider the imported package as a seperate one. In particular, it will complain that the imported file is not defined in the include field of the tsconfig.json. For that reason, we need to reference the source sub-project from the tests sub-project 
 */
const TSCONFIG_TESTS: ReadonlyRecord = {
  extends: './tsconfig.base.json',
  include: [tsConfigStyleIncludeForTestsFiles],
  // The tests project needs to import the source project. The other possibility would be to create a package.json in the tests folder
  references: [{ path: tsConfigSrcFilename }],
  /* NoEmit cannot be set to true in a referenced project even though we never emit anything . rootDir, outDir and declarationDir need to be set otherwise Typescript will complain */
  compilerOptions: {
    tsBuildInfoFile: `.tsbuildinfo/${testsMark}.tsbuildinfo`,
    rootDir: '.',
    outDir: prodFolderName,
    declarationDir: `${prodFolderName}/${testsFolderName}/${typesFolderName}`,
    //declarationMap: true,
  },
};

// Must work at all levels: top, monorepo, one-package repo, subrepo
const TSCONFIG_OTHERS: ReadonlyRecord = {
  extends: './tsconfig.base.json',
  exclude: [...foldersWithoutConfigFiles, ...filesGeneratedByThirdParties],
  /* NoEmit cannot be set to true in a referenced project even though we never emit anything . rootDir, outDir and declarationDir need to be set otherwise Typescript will complain */
  compilerOptions: {
    tsBuildInfoFile: `.tsbuildinfo/${othersMark}.tsbuildinfo`,
    rootDir: '.',
    outDir: `${prodFolderName}/${othersFolderName}`,
    declarationDir: `${prodFolderName}/${othersFolderName}/${typesFolderName}`,
    //declarationMap: true
  },
};

const TSCONFIG_OTHERS_FOR_CONFIGS_PACKAGE: ReadonlyRecord = {
  ...TSCONFIG_OTHERS,
  // The others project of the configs package needs to import the source project for eslintConfig and prettierConfig. See comment about TSCONFIG_TESTS for more details
  references: [{ path: tsConfigSrcFilename }],
};

/**
 * Specific tsconfig used by docgen. Some examples can be provided as jsdoc comments and these
 * examples usually require the node environment
 */
const TSCONFIG_DOCGEN: ReadonlyRecord = {
  extends: './tsconfig.base.json',
  include: `${sourceFolderName}/${allFilesPattern}`,
  compilerOptions: {
    allowJs: false,
    checkJs: false,
  },
};

const GIT_IGNORE = [
  ...foldersGeneratedByThirdParties.map((folderName) => `/${folderName}/`),
  ...filesGeneratedByThirdParties.map((fileName) => `/${fileName}`),
].join('\n');

/*Although it is possible to have the vitest configuration inside the vite configuration files, this is usually not a good idea. The vite configuration is useful for bundling whereas the vitest configuration is useful for testing */
const VITEST_CONFIG_SOURCE = (name: string) => `import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    projects: [
      {
        test: {
          include: ['tests/*.ts'],
          exclude: ['node_modules/**'],
          name: 'Repo ${name}',
          isolate: false,
          fileParallelism: false,
          pool: 'threads',
        },
      },
    ],
  },
});`;

const VITEST_CONFIG_NO_SOURCE = `import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    projects: ['${packagesFolderName}/*'],
  },
})`;

const VITE_CONFIG_TRANSPILE = `/// <reference types="vitest" />
import { defineConfig } from 'vite';

export default defineConfig();`;

const VITE_CONFIG_BUNDLE = `/// <reference types="vitest" />
import { defineConfig } from 'vite';

export default defineConfig();`;

const MADGE_CONFIG = `{
	"detectiveOptions": {
		"ts": {
			"skipTypeImports": true
		}
	}
}`;

const PNPM_WORKSPACE_CONFIG = `packages:
  - '${packagesFolderName}/*'
  - '${packagesFolderName}/*/${packagesFolderName}/*'
  
trustPolicy: no-downgrade
shellEmulator: true`;

const VSCODE_WORKSPACE_CONFIG = ({
  name,
  allPackagesPaths,
}: {
  readonly name: string;
  allPackagesPaths: ReadonlyArray<string>;
}) =>
  prettyStringify({
    folders: allPackagesPaths.map((path) => ({ path })),
    settings: {
      'typescript.tsdk': `${name}/${npmFolderName}/typescript/lib`,
    },
  });

/**
 * Publishes a sub-package or a one-package repo to npm. Can be started manually. In that case, it
 * uses the release number of the last issued release. It can be useful if the publish action has
 * failed and no modification to the code is necessary. If a modification to the code is
 * necessary, a new release will have to be issued.
 */
const GITHUB_WORKFLOWS_PUBLISH_SCRIPT = readFileSync(
  join(import.meta.dirname, 'assets/githubWorkflowsPublish.yml'),
  'utf8',
);

/** Creates the documentation for the package. Must be started manually. */
const GITHUB_WORKFLOWS_PAGES_SCRIPT = readFileSync(
  join(import.meta.dirname, 'assets/githubWorkflowsPages.yml'),
  'utf8',
);

const DOCGEN_CONFIG: ReadonlyRecord = {
  parseCompilerOptions: `./${tsConfigDocGenFilename}`,
  examplesCompilerOptions: `./${tsConfigDocGenFilename}`,
  srcDir: `./${sourceFolderName}`,
  outDir: docsFolderName,
  exclude: [
    ...allTsFiles.map((ext) => `${sourceFolderName}/${internalFolderName}/${ext}`),
    `${sourceFolderName}/index.ts`,
  ],
  enforceDescriptions: true,
  enforceVersion: false,
};

const JUST_THE_DOCS_CONFIG = (name: string) => `remote_theme: mikearnaldi/just-the-docs
search_enabled: true
aux_links:
  "GitHub":
    - "//github.com/${owner}/${name}"`;

/**
 * Constructor
 *
 * @category Constructors
 */
export const make = (data: {
  readonly configurationFiles: ReadonlyRecord;
  readonly linkedPackage: Package.Type;
}): Type => Object.assign(Object.create(_proto), data) as never;

/**
 * Returns a function that takes configuration files and saves them in self
 *
 * @category Destructors
 */
export const save = async (self: Type) => {
  const { path } = self.linkedPackage;

  for (const [filename, fileContent] of Object.entries(self.configurationFiles)) {
    const contentToWriteFunc =
      typeof fileContent === 'string' ? () => fileContent
      : extname(filename) === '.json' ? () => prettyStringify(fileContent)
      : () => {
          throw new Error(
            `Entry '${filename}' in '${configFilename}' must have value of type string`,
          );
        };

    const targetFilename = join(path, filename);
    // Create directory in case it does not exist
    /* eslint-disable-next-line functional/no-expression-statements*/
    await mkdir(dirname(targetFilename), { recursive: true });

    /* eslint-disable-next-line functional/no-expression-statements*/
    await writeAutogeneratedFile({ path: targetFilename, newContents: contentToWriteFunc() });
  }
};

/** PackageFiles instance that implements what is necessary in all situations. */
const anyPackage = ({
  name,
  description,
  scripts,
  isConfigsPackage,
}: {
  readonly name: string;
  readonly description: string;
  readonly scripts: StringRecord;
  readonly isConfigsPackage: boolean;
}): ReadonlyRecord => ({
  // Used by the format script
  [prettierConfigFilename]: PRETTIER_CONFIG,
  // Used by the format script
  [prettierIgnoreFilename]: PRETTIER_IGNORE,
  // Used by the tscheck script
  [tsConfigBaseFilename]: TSCONFIG_BASE,
  [packageJsonFilename]: {
    name: `${slashedScope}${name}`,
    // Needs to be present even at the top or root of a monorepo because there are some javascript config files
    type: 'module',
    description,
    author: 'Jérôme MARTIN',
    license: 'MIT',
    scripts: {
      // tests can be run at all levels, even at non project levels because there are vitest projects
      test: 'vitest run',
      tscheck: `tsc -b ${tsConfigFilename} --force`,
      lint: 'eslint .',
      'lint-and-analyze': 'eslint . --stats -f json > eslint-stats.json',
      'lint-rules': 'pnpx @eslint/config-inspector',
      format: 'prettier . --write',
      'generate-config-files': `${tsExecuter} ${binariesPath(isConfigsPackage)}/generate-config-files.ts -activePackageOnly`,
      rmrf: `node ${binariesPath(isConfigsPackage)}/rmrf.ts`,
      mkdirp: `node ${binariesPath(isConfigsPackage)}/mkdirp.ts`,
      'clean-node-modules': `${tsExecuter} ${binariesPath(isConfigsPackage)}/clean-node-modules.ts -activePackageOnly`,
      // Suppress package.json after because once suppressed the rmrf script no longer exists
      'clean-config-files': `${tsExecuter} ${binariesPath(isConfigsPackage)}/clean-config-files.ts -activePackageOnly`,
      'reinstall-all-dependencies': 'pnpm i --force',
      ...scripts,
    },
    devDependencies:
      isConfigsPackage ? baseDevDependencies : (
        {
          ...baseDevDependencies,
          ...configsPeerDependencies,
          [`${slashedScope}${configsPackageName}`]: `git+ssh://${versionControlService}/${owner}/${configsPackageName}`,
        }
      ),
    ...(isConfigsPackage ? { peerDependencies: configsPeerDependencies } : {}),
  },
});

/**
 * PackageFiles instance taht implements what is necessary in a package that has no code (no esm
 * directory). This package is also a workspace.
 */
const noSourcePackage: ReadonlyRecord = {
  // Used by the checks script
  [tsConfigFilename]: TSCONFIG_OTHERS,
  // Used by the checks script
  [eslintConfigFilename]: ESLINT_CONFIG_OTHERS,
  // Used by the test script
  [vitestConfigFilename]: VITEST_CONFIG_NO_SOURCE,
  [packageJsonFilename]: {
    scripts: {
      checks: 'pnpm tscheck && pnpm lint',
      'clean-all-node-modules': 'pnpm -r -include-workspace-root=true --reverse clean-node-modules',
      'clean-all-config-files': 'pnpm -r -include-workspace-root=true --reverse clean-config-files',
      'clean-all-prod': 'pnpm -r --parallel --aggregate-output clean-prod',
      // --if-present is necessary because it is possible that no package in the workspace has a build script
      'build-all': 'pnpm --if-present -r build',
      // --if-present is necessary because it is possible that no package in the workspace has an auto-update-imports script
      'auto-update-imports-for-all':
        'pnpm --if-present -r --parallel --aggregate-output auto-update-imports',
      // --if-present is necessary because it is possible that no package in the workspace has an update-imports script
      'update-imports-for-all': 'pnpm --if-present -r --parallel --aggregate-output update-imports',
      'generate-all-configs': 'pnpm -r --parallel --aggregate-output generate-configs',
      'tscheck-all': 'pnpm -r -include-workspace-root=true tscheck',
      'lint-all': 'pnpm -r -include-workspace-root=true lint',
      'checks-all': 'pnpm -r -include-workspace-root=true checks',
      'format-all': 'pnpm -r -include-workspace-root=true format',
    },

    /*pnpm: {
        patchedDependencies: {},
        overrides: {
          //'tsconfig-paths': '^4.0.0'
        },
      },*/
  },
};

/**
 * PackageFiles instance that implements what is necessary in a package that has code (an esm
 * directory). This package is also a workspace.
 */
/*
 * For a one-package repo, name and parentName are the same. For a sub package, name is the
 * name of the sub package and parentName the name of the monorepo that contains it.
 */
const sourcePackage = ({
  parentName,
  name,
  dependencies,
  devDependencies,
  peerDependencies,
  examples,
  buildMethod,
  environment,
  isPublished,
  hasDocGen,
  keywords,
  useEffectAsPeerDependency,
  useEffectPlatform,
  packagePrefix,
  isConfigsPackage,
  indexTsContents,
  packageJsonExports,
}: {
  readonly parentName: string;
  readonly name: string;
  readonly dependencies: StringRecord;
  readonly devDependencies: StringRecord;
  readonly peerDependencies: StringRecord;
  readonly examples: ReadonlyArray<string>;
  readonly buildMethod: string;
  readonly environment: string;
  readonly isPublished: boolean;
  readonly hasDocGen: boolean;
  readonly keywords: ReadonlyArray<string>;
  readonly useEffectAsPeerDependency: boolean;
  readonly useEffectPlatform: string;
  readonly packagePrefix: string | undefined;
  readonly isConfigsPackage: boolean;
  readonly indexTsContents: string | undefined;
  readonly packageJsonExports: ReadonlyRecord | undefined;
}): ReadonlyRecord => {
  const [finalDependencies, finalPeerDependencies] =
    useEffectAsPeerDependency ?
      [dependencies, { ...peerDependencies, ...effectDependencies }]
    : [{ ...dependencies, ...effectDependencies }, peerDependencies];

  const buildConfig = (): ReadonlyRecord => {
    if (buildMethod === 'None') return {};

    if (buildMethod === 'Transpile')
      return {
        [viteConfigFilename]: VITE_CONFIG_TRANSPILE,
        [packageJsonFilename]: {
          sideEffects: [],
          scripts: {
            compile:
              // tsc builds but also generate types. All my packages ship with the sideEffects-free key in package.json. And this is perfectly well understood by vite and rollup. So annotate-pure-calls is only necessary for published packages that might be used by clients who use old bundlers. As far as I am concerned, I do not need cjs code. Likewise, this is only necessary for published packages.
              `tsc -b ${tsConfigSrcFilename} --force`
              + (isPublished ?
                ` && babel ${prodFolderName}/${sourceFolderName} --out-dir ${prodFolderName}/${commonJsFolderName}`
                + '--plugins @babel/transform-export-namespace-from --plugins @babel/transform-modules-commonjs  --source-maps'
              : '')
              + ` && babel ${prodFolderName} --plugins annotate-pure-calls --out-dir ${prodFolderName} --source-maps`
              + ' && pnpm prodify-lib',
          },
        },
      };
    if (buildMethod === 'Bundle')
      return {
        [viteConfigFilename]: VITE_CONFIG_BUNDLE,
        [packageJsonFilename]: {
          module: `./${sourceFolderName}/index.js`,
          scripts: {
            bundle: 'bundle-files',
            compile: `pnpm bundle && pnpm prodify-bundle`,
          },
        },
      };

    // 'BundleWithDeps' , 'AppClient'
    throw new Error(`Disallowed value for 'buildMethod' parameter. Actual: '${buildMethod}'`);
  };

  const visibilityConfig: ReadonlyRecord =
    isPublished ?
      {
        [packageJsonFilename]: {
          bugs: {
            url: `https://github.com/${owner}/${parentName}/issues`,
          },
          funding: [
            {
              type: 'ko-fi',
              url: 'https://ko-fi.com/parischap',
            },
          ],
          // Put specific keywords in first position so important keywords come out first
          keywords: [...keywords, 'effect', 'typescript', 'functional-programming'],
          scripts: {
            // Called by the publish github action defined in configInternalRepo.ts/
            'build-and-publish': 'pnpm build && pnpm checks && pnpm publish-to-npm',
            // npm publish ./dist --access=public does not work
            'publish-to-npm': `cd ${prodFolderName} && npm publish --access=public && cd ..`,
          },
        },
      }
    : {
        [packageJsonFilename]: {
          private: true,
        },
      };

  const docGenConfig: ReadonlyRecord =
    hasDocGen ?
      {
        [packageJsonFilename]: {
          scripts: {
            docgen: 'docgen',
          },
          devDependencies: docGenDependencies,
        },
        [tsConfigDocGenFilename]: TSCONFIG_DOCGEN,
        [docgenConfigFilename]: DOCGEN_CONFIG,
      }
    : {};

  const platformConfig = (): ReadonlyRecord => {
    if (useEffectPlatform === 'No') return {};

    if (useEffectPlatform === 'AsDependency')
      return {
        [packageJsonFilename]: {
          dependencies: effectPlatformDependencies,
        },
      };

    if (useEffectPlatform === 'AsPeerDependency')
      return {
        [packageJsonFilename]: {
          peerDependencies: effectPlatformDependencies,
        },
      };

    throw new Error(
      `Disallowed value for 'useEffectPlatform' parameter. Actual: '${useEffectPlatform}'`,
    );
  };

  const environmentConfig = (): ReadonlyRecord => {
    const base = {
      // Used by the tscheck script
      [tsConfigFilename]: TSCONFIG,
      // Used by the tsConfig file
      [tsConfigOthersFilename]:
        isConfigsPackage ? TSCONFIG_OTHERS_FOR_CONFIGS_PACKAGE : TSCONFIG_OTHERS,
      // Used by the tsConfig file
      [tsConfigExamplesFilename]: TSCONFIG_EXAMPLES,
      // Used by the tsConfig file
      [tsConfigTestsFilename]: TSCONFIG_TESTS,
    };

    if (environment === 'Browser')
      return {
        ...base,
        // Used by the checks script
        [tsConfigSrcFilename]: TSCONFIG_BROWSER_SOURCE,
        // Used by the checks script
        // We don't use any dom specifities because it must run on the server. It's all hidden away in preact
        [eslintConfigFilename]: ESLINT_CONFIG_BROWSER_SOURCE,
      };

    if (environment === 'Node')
      return {
        ...base,
        // Used by the checks script
        [tsConfigSrcFilename]: TSCONFIG_NODE_SOURCE,
        // Used by the checks script
        [eslintConfigFilename]: ESLINT_CONFIG_NODE_SOURCE,
      };

    if (environment === 'Plain')
      return {
        ...base,
        // Used by the checks script
        [tsConfigSrcFilename]: TSCONFIG_PLAIN_SOURCE,
        // Used by the checks script
        [eslintConfigFilename]: ESLINT_CONFIG_PLAIN_SOURCE,
      };

    throw new Error(`Disallowed value for 'environment' parameter. Actual: '${environment}'`);
  };

  return deepMerge(
    {
      // Used by the circular script
      [madgeConfigFilename]: MADGE_CONFIG,
      // Used by the test script
      [vitestConfigFilename]: VITEST_CONFIG_SOURCE(name),
      ...(packagePrefix === undefined || indexTsContents === '' ?
        {}
      : { [join(sourceFolderName, indexTsFilename)]: indexTsContents }),
      [packageJsonFilename]: {
        module: `./${sourceFolderName}/index.js`,
        exports: packageJsonExports,
        ...(Object.keys(finalDependencies).length === 0 ? {} : { dependencies: finalDependencies }),
        ...(Object.keys(finalPeerDependencies).length === 0 ?
          {}
        : { peerDependencies: finalPeerDependencies }),
        devDependencies: {
          /* Include test-utils for tests except if the package is:
          - test-utils because it does not need to inclue itself
          - configs: to avoid circular dependencies
          */
          ...sourceDevDependencies,
          ...devDependencies,
        },
        scripts: {
          circular: `madge --extensions ts --circular --no-color --no-spinner ${sourceFolderName}`,
          'clean-prod': `pnpm rmrf ${prodFolderName} && pnpm mkdirp ${prodFolderName}`,
          checks: 'pnpm circular && pnpm tscheck && pnpm lint && pnpm test',
          build: 'pnpm clean-prod && pnpm compile && cd ${prodFolderName} && pnpm i && cd ..',
          examples: examples
            .map((exampleName) => `${tsExecuter} ${examplesFolderName}/${exampleName}`)
            .join('&&'),
          ...(packagePrefix === undefined ?
            {}
          : {
              'update-imports': `node ${binariesPath(isConfigsPackage)}/update-imports.ts run ${packagePrefix}`,
              'auto-update-imports': `node ${binariesPath(isConfigsPackage)}/update-imports.ts watch ${packagePrefix}`,
            }),
        },
        // Must be present even for private packages as it can be used for other purposes
        repository: {
          type: 'git',
          // Use git+https protocol as specified in npm documentation
          url: `git+https://${versionControlService}/${owner}/${parentName}.git`,
          ...(name === parentName ?
            {}
          : {
              directory: `${packagesFolderName}/${name}`,
            }),
        },
        // Must be present even for private packages as it can be used for instance by docgen
        homepage:
          // Use https protocol as specified in npm documentation
          `https://${versionControlService}/${owner}/${parentName}`
          + (name === parentName ? '' : `/tree/master/${packagesFolderName}/${name}`),
      },
    },
    buildConfig(),
    visibilityConfig,
    docGenConfig,
    platformConfig(),
    environmentConfig(),
  );
};

/** PackageFiles instance that implements what is necessary at the root of a git (and github) repo */
const repo = ({
  docGenParameters,
  isPublished,
}: {
  readonly docGenParameters?: { readonly name: string; readonly description: string };
  readonly isPublished: boolean;
}): ReadonlyRecord => ({
  ...(isPublished ?
    /* Github actions need to be at the root of the github repo. This action calls a script `build-and-publish` but changes the working directory to the published package directory before calling them. So this script must be in configInternalProject.ts.
     */
    {
      [`${githubFolderName}/${workflowsFolderName}/${githubWorkflowsPublishFilename}`]:
        GITHUB_WORKFLOWS_PUBLISH_SCRIPT,
    }
  : {}),
  ...(docGenParameters !== undefined ?
    {
      /* Github actions need to be at the root of the github repo. This action calls a script `prepare-docs'`  */
      [`${githubFolderName}/${workflowsFolderName}/${githubWorkflowsPagesFilename}`]:
        GITHUB_WORKFLOWS_PAGES_SCRIPT,
      // Used by the github pages.yml action
      [`${docsFolderName}/${docsIndexMdFilename}`]: docGenParameters.description,
      // Used by the github pages.yml action
      [`${docsFolderName}/${docsConfigYmlFilename}`]: JUST_THE_DOCS_CONFIG(docGenParameters.name),
    }
  : {}),
  [gitIgnoreFilename]: GIT_IGNORE,
  [packageJsonFilename]: {
    packageManager,
    ...(docGenParameters !== undefined ?
      {
        scripts: {
          // --if-present is necessary because it is possible that no package in the workspace has a docgen script
          'prepare-docs':
            'pnpm -r --if-present -include-workspace-root=true --parallel --aggregate-output docgen && compile-docs',
        },
      }
    : {}),

    /*pnpm: {
      patchedDependencies: {},
      overrides: {
        //'tsconfig-paths': '^4.0.0'
      },
    },*/
  },
});

/** PackageFiles instance to be used at the root (top) of a monorepo. */
export const monorepo = ({
  name,
  description,
  linkedPackage,
}: {
  readonly name: string;
  readonly description: string;
  readonly path: string;
  readonly linkedPackage: Package.Type;
}): Type =>
  make({
    configurationFiles: deepMerge(
      anyPackage({
        name,
        description,
        scripts: {},
        isConfigsPackage: false,
      }),
      repo({
        // In a monorepo, we need to have the docGen stuff in case one of the subrepos needs to be documented
        docGenParameters: { name, description },
        // In a monorepo, we need to have the publish script in case one of the subrepos needs to be published
        isPublished: true,
      }),
      noSourcePackage,
      {
        // Used by all scripts to define scope of -r flag
        [pnpmWorkspaceFilename]: PNPM_WORKSPACE_CONFIG,
      },
    ),
    linkedPackage,
  });

/** PackageFiles instance to be used at the root (top) of a project. */
export const topPackage = ({
  name,
  description,
  allSourcePackages,
  allPackagesPaths,
  linkedPackage,
}: {
  readonly name: string;
  readonly description: string;
  readonly allSourcePackages: ReadonlyArray<string>;
  readonly allPackagesPaths: ReadonlyArray<string>;
  readonly linkedPackage: Package.Type;
}): Type =>
  make({
    configurationFiles: {
      ...deepMerge(
        anyPackage({
          name,
          description,
          scripts: {},
          isConfigsPackage: false,
        }),
        noSourcePackage,
      ),
      // Used by all scripts to define scope of -r flag
      [pnpmWorkspaceFilename]:
        PNPM_WORKSPACE_CONFIG
        + (allSourcePackages.length !== 0 ?
          `
overrides:
${allSourcePackages.map((packageName) => `  '${slashedScope}${packageName}': 'workspace:*'`).join('\n')}`
        : ''),
      // Used by vscode
      [`${name}.code-workspace`]: VSCODE_WORKSPACE_CONFIG({
        name,
        allPackagesPaths,
      }),
    },
    linkedPackage,
  });

/** PackageFiles instance to be used in a one-package repo */
export const onePackageRepo = ({
  name,
  isConfigsPackage,
  description,
  dependencies,
  devDependencies,
  peerDependencies,
  examples,
  scripts,
  environment,
  buildMethod,
  isPublished,
  hasDocGen,
  keywords,
  useEffectAsPeerDependency,
  useEffectPlatform,
  packagePrefix,
  indexTsContents,
  packageJsonExports,
  linkedPackage,
}: SourcePackagesPackageFilesParameters & {
  readonly isConfigsPackage: boolean;
  readonly linkedPackage: Package.Type;
}): Type =>
  make({
    configurationFiles: deepMerge(
      anyPackage({
        name,
        description,
        scripts,
        isConfigsPackage,
      }),
      repo({
        ...(hasDocGen ? { docGenParameters: { name, description } } : {}),
        isPublished,
      }),
      sourcePackage({
        name,
        parentName: name,
        dependencies,
        devDependencies,
        peerDependencies,
        examples,
        buildMethod,
        environment,
        isPublished,
        hasDocGen,
        keywords,
        useEffectAsPeerDependency,
        useEffectPlatform,
        packagePrefix,
        isConfigsPackage,
        indexTsContents,
        packageJsonExports,
      }),
    ),
    linkedPackage,
  });

/** PackageFiles instance to be used in a sub package */
export const subPackage = ({
  parentName,
  name,
  description,
  dependencies,
  devDependencies,
  peerDependencies,
  examples,
  scripts,
  environment,
  buildMethod,
  isPublished,
  hasDocGen,
  keywords,
  useEffectAsPeerDependency,
  useEffectPlatform,
  packagePrefix,
  indexTsContents,
  packageJsonExports,
  linkedPackage,
}: SourcePackagesPackageFilesParameters & {
  readonly parentName: string;
  readonly linkedPackage: Package.Type;
}): Type =>
  make({
    configurationFiles: deepMerge(
      anyPackage({
        name,
        description,
        scripts,
        isConfigsPackage: false,
      }),
      sourcePackage({
        name,
        parentName,
        dependencies,
        devDependencies,
        peerDependencies,
        examples,
        buildMethod,
        environment,
        isPublished,
        hasDocGen,
        keywords,
        useEffectAsPeerDependency,
        useEffectPlatform,
        packagePrefix,
        isConfigsPackage: false,
        indexTsContents,
        packageJsonExports,
      }),
    ),
    linkedPackage,
  });
