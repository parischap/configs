/**
 * Module that defines the format of a list of parameters, i.e. for each parameter the allowed name
 * and value type and an optional default value. The parameters must be provided as an array of
 * name/value pairs.
 */
/* This module must not import any external dependency. It must be runnable without a package.json because it is used by the generate-config-files.ts bin */
import { type Data, type ReadonlyRecord } from '../../shared-utils/utils.js';
import * as SchemaParameterDescriptor from './ParameterDescriptor.js';

/**
 * Module tag
 *
 * @category Models
 */
export const moduleTag = '@parischap/configs/internal/bin-utils/Schema/Format/';
const _TypeId: unique symbol = Symbol.for(moduleTag) as _TypeId;
type _TypeId = typeof _TypeId;

namespace ParameterDescriptors {
  export interface Type extends ReadonlyRecord<string, SchemaParameterDescriptor.Any> {}
}

/**
 * Type of a SchemaFormat
 *
 * @category Models
 */
export class Type<P extends ParameterDescriptors.Type> {
  /**
   * Object whose keys are the allowed property names and whose values describe the types and
   * optional default values of these properties
   */
  readonly descriptors: P;

  /** Class constructor */
  constructor(params: Data<Type<P>>) {
    this.descriptors = params.descriptors;
  }

  /** Static constructor */
  static make<P extends ParameterDescriptors.Type>(params: Data<Type<P>>): Type<P> {
    return new Type<P>(params);
  }

  /** @internal */
  get [_TypeId](): _TypeId {
    return _TypeId;
  }
}

/**
 * Constructor
 *
 * @category Constructors
 */
export const make = <const P extends ParameterDescriptors.Type>(params: Data<Type<P>>): Type<P> =>
  Type.make(params);

/**
 * Returns the descriptors property of `self`
 *
 * @category Destructors
 */
export const descriptors = <const P extends ParameterDescriptors.Type>(self: Type<P>): P =>
  self.descriptors;

/**
 * SchemaFormat instance for a no source package
 *
 * @category Instances
 */
export const noSourcePackage = make({
  descriptors: {
    description: SchemaParameterDescriptor.make({ expectedType: 'string' }),
  },
});

/**
 * SchemaFormat instance for a source package
 *
 * @category Instances
 *
 *   - description : description of the package
 *   - dependencies: dependencies used by the package except Effect and Effect platform (default value:
 *       {})
 *   - devDependencies: devDependencies used by the package (default value: {})
 *   - peerDependencies: peerDependencies used by the package except Effect (default value: {})
 *   - examples: array of available examples to add as `examples` script under the `package.json`
 *       scripts field (default value: [])
 *   - scripts: scripts to add to `package.json` (default value: {})
 *   - environment: one of `Browser`, `Node` or `Plain`. Note that, in our case, we do not use the DOM
 *       specific variables in the `Browser` environment because the browser code must be runnable
 *       on the server for server-side rendering. All the DOM manipulation is hidden away in
 *       Preact.
 *   - buildMethod:
 *   - NoBundling: all modules in the `esm` directory, except those under the `internal`and `bin`
 *       subdirectories, are simply transpiled to JavaScript. Nothing gets bundled. If the package
 *       uses any dependencies, they must be installed in the prod package as well. This is usually
 *       a good choice for libraries.
 *   - LightBundling: all modules in the `esm` directory except those under the `internal` subdirectory
 *       are transpiled to JavaScript and bundled with the modules under the `internal`
 *       subdirectory. If the package uses any dependencies, they must be installed in the prod
 *       package as well. This is usually a good choice for code that does not need to ship as a
 *       standalone package. Not bundling external dependencies allows to keep the package small,
 *       reduce build and start time as all the packages need not be loaded at once. This is usually
 *       a good choice for a web server.
 *   - DeepBundling: all modules in the `esm` directory except those under the `internal` subdirectory
 *       are transpiled to JavaScript and bundled with the modules under the `internal` subdirectory
 *       and all installed packages. If the package uses any dependencies, they will not be
 *       installed in the prod package. This is usually a good choice for a standalone command.
 *   - isPublished: boolean that indicates if the package will be published to NPM
 *   - hasDocGen: boolean that indicates if package documentation must be generated by docgen. Note that
 *       no documentation will be produced for modules under the `internal` directory.
 *   - keywords: array of keywords to add to the package. Will be ignored if the package is private
 *       (default: [])
 *   - useEffectAsPeerDependency: Effect is by default added as dependency to all packages. If this flag
 *       is set to true, it is added as a peerDependency
 *   - useEffectPlatform: if true, Effect platform and all its peerDependencies are added as dependency
 *       to the package.
 *   - packagePrefix: string that will be added to automatically generated namespace imports for the
 *       package. namespace imports will be automatically generated even if packagePrefix is an
 *       empty string. To deactivate it, omit the field. Namespace imports are generated for all
 *       JavaScript files except those under the `internal` and `bin` subdirectories.
 */
export const sourcePackage = make({
  descriptors: {
    description: SchemaParameterDescriptor.make({ expectedType: 'string' }),
    dependencies: SchemaParameterDescriptor.make({ expectedType: 'record', defaultValue: {} }),
    devDependencies: SchemaParameterDescriptor.make({ expectedType: 'record', defaultValue: {} }),
    peerDependencies: SchemaParameterDescriptor.make({ expectedType: 'record', defaultValue: {} }),
    examples: SchemaParameterDescriptor.make({ expectedType: 'array', defaultValue: [] }),
    scripts: SchemaParameterDescriptor.make({ expectedType: 'record', defaultValue: {} }),
    environment: SchemaParameterDescriptor.make({ expectedType: 'string' }),
    buildMethod: SchemaParameterDescriptor.make({ expectedType: 'string' }),
    isPublished: SchemaParameterDescriptor.make({ expectedType: 'boolean' }),
    hasDocGen: SchemaParameterDescriptor.make({ expectedType: 'boolean' }),
    keywords: SchemaParameterDescriptor.make({ expectedType: 'array', defaultValue: [] }),
    useEffectAsPeerDependency: SchemaParameterDescriptor.make({ expectedType: 'boolean' }),
    useEffectPlatform: SchemaParameterDescriptor.make({
      expectedType: 'string',
      defaultValue: 'No',
    }),
    packagePrefix: SchemaParameterDescriptor.make({
      expectedType: 'stringOrUndefined',
      defaultValue: undefined,
    }),
  },
});

/**
 * SchemaFormat instance for the arguments of a binary that accepts a filtering flag
 *
 * @category Instances
 */
export const filteringArgs = make({
  descriptors: {
    '-activePackageOnly': SchemaParameterDescriptor.make({
      expectedType: 'boolean',
      defaultValue: false,
    }),
  },
});

/**
 * SchemaFormat instance for the `update-exports` command
 *
 * @category Instances
 */
export const updateExportsArgs = make({
  descriptors: {
    '-activePackageOnly': SchemaParameterDescriptor.make({
      expectedType: 'boolean',
      defaultValue: false,
    }),
    '-watch': SchemaParameterDescriptor.make({
      expectedType: 'boolean',
      defaultValue: false,
    }),
  },
});

/**
 * Function that takes a list of parameters provided as name/value pairs
 *
 * @category Combinators
 */
export const injectDefaultsAndValidate = <P extends ParameterDescriptors.Type>(
  self: Type<P>,
  {
    errorPrefix = '',
    allowStringConversion = false,
  }: { readonly errorPrefix?: string; readonly allowStringConversion?: boolean } = {},
): ((
  parameters: ReadonlyArray<readonly [string, unknown]>,
) => /* eslint-disable-next-line functional/prefer-readonly-type */
{
  [k in keyof P]: SchemaParameterDescriptor.ExpectedType<P[k]>;
}) => {
  const descriptors = Object.entries(self.descriptors);
  return (parameters) => {
    // Copy the parameterDescriptors
    const parameterDescriptorsCpy = Object.fromEntries(
      descriptors.map(([key, value]) => [
        key,
        /* eslint-disable-next-line functional/prefer-readonly-type */
        { ...value } as SchemaParameterDescriptor.Any & { value?: unknown },
      ]),
    );

    for (const [key, value] of parameters) {
      const descriptor = parameterDescriptorsCpy[key];
      if (descriptor === undefined) throw new Error(`${errorPrefix}Unexpected parameter '${key}'`);

      if ('value' in descriptor) throw new Error(`${errorPrefix}Parameter '${key}' received twice`);

      /* eslint-disable-next-line functional/no-expression-statements, functional/immutable-data */
      descriptor.value = SchemaParameterDescriptor.validate({
        value,
        allowStringConversion,
        errorPrefix,
      })(descriptor);
    }
    return Object.fromEntries(
      Object.entries(parameterDescriptorsCpy).map(([key, extendedDescriptor]) => {
        if ('value' in extendedDescriptor) return [key, extendedDescriptor['value']] as const;
        if ('defaultValue' in extendedDescriptor)
          return [key, extendedDescriptor['defaultValue']] as const;
        throw new Error(`${errorPrefix}Mandatory parameter '${key}' was not provided`);
      }),
    ) as never;
  };
};
