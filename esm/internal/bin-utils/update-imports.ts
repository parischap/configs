/**
 * Adds an exports entry in index.js and creates namespace exports entries for each file in the `esm` directory not in the `internal` or `binaries` sub-directory.
 */
/* This module must only use Typescript syntax understandable by Node with the --experimental-transform-types flag */
import {
  binariesFolderName,
  indexTsFilename,
  internalFolderName,
  javaScriptExtensions,
  packageJsonFilename,
  sourceFolderName
} from '../shared-utils/constants.js';

import { readFile, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { isRecord, Record } from '../shared-utils/types.js';
import { fromOSPathToPosixPath, prettyStringify, readFilesRecursively, writeAutogeneratedFile } from '../shared-utils/utils.js';

const capitalizeFirstLetter = (s: string): string => s.charAt(0).toUpperCase() + s.slice(1);

export const generateImports = async ({
  sourcePath,
  packagePrefix,
  keepFileExtensions,
}: {
  readonly sourcePath: string,
  readonly packagePrefix: string;
  readonly keepFileExtensions: boolean;
}):Promise<readonly [indexTsContents: string, packageJsonExports:Record]> => {

  const sourceFiles = (
      await readFilesRecursively({ path: sourcePath, foldersToExclude:[internalFolderName,binariesFolderName ], dontFailOnInexistentPath: false })
    ).filter(
      ({ extension }) =>
        javaScriptExtensions.includes(extension)
    );

    return [sourceFiles.filter(
      ({ name }) =>
        name !== indexTsFilename,
    )
          // path.join removes upfront './' but typescript requires them so we must add them
          .map(
            ({ bareName, relativeParentPath, extension }) =>
            {
              const pathedName = fromOSPathToPosixPath(join(relativeParentPath, bareName))
              return `export * as ${packagePrefix}${pathedName.split('/').map(capitalizeFirstLetter).join('')} \
              from './${pathedName}.${keepFileExtensions ?extension: 'js'}';`
            }).join('\n'),{

          ...Object.fromEntries(sourceFiles.map(
            ({ name,bareName, relativeParentPath, extension }) =>
            {
              const pathedName = fromOSPathToPosixPath(join(relativeParentPath, bareName))
              return [name ===  indexTsFilename ? '.' :`./${packagePrefix}${pathedName.split('/').map(capitalizeFirstLetter).join('')}`,
                {
            import: `./${pathedName}.${keepFileExtensions ?extension: 'js'}`,
          }
              ]as const
            }
              
          )),
          './tests': {
            import: `./${sourceFolderName}/index.tests.ts`,
          },
        }] as const
  

};

export const updateImports = async ({
  packagePath,
  packagePrefix,
  keepFileExtensions,
  indent
}: {
  readonly packagePath: string,
  readonly packagePrefix: string;
  readonly keepFileExtensions: boolean;
  readonly indent:string
}) => {
  const sourcePath = join(packagePath, sourceFolderName);
  
  const [indexTsContents, packageJsonExports] = await generateImports({sourcePath,packagePrefix,keepFileExtensions})

  console.log(`${indent}Regenerating '${indexTsFilename}'`);
  const indexTsPath = join(sourcePath, indexTsFilename);
  await writeAutogeneratedFile({path:indexTsPath, newContents:indexTsContents})

console.log(`${indent}Regenerating namespace exports in '${packageJsonFilename}'`);
const packageJsonPath = join(packagePath, packageJsonFilename);
/* eslint-disable-next-line functional/no-expression-statements */
const packageJsonContent = await readFile(packageJsonPath, 'utf8');
const packageJson:unknown = JSON.parse(packageJsonContent)

if (!isRecord(packageJson))
  throw new Error(`'${packageJsonFilename}' must represent a record`)

/* eslint-disable-next-line functional/no-expression-statements */
await writeFile(
      packageJsonPath,
      prettyStringify({...packageJson,
        exports: packageJsonExports,
      })
    );

};

