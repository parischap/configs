/**
 * Adds an exports entry in index.js and creates namespace exports entries for each file in the `esm` directory not in the `internal` or `binaries` sub-directory.
 */
/* This module must only use Typescript syntax understandable by Node with the --experimental-transform-types flag */
import {
  autoGeneratedFileWarning,
  binariesFolderName,
  indexTsFilename,
  internalFolderName,
  javaScriptExtensions,
  packageJsonFilename,
  sourceFolderName,
} from '../shared-utils/constants.js';

import { readFile, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { isRecord } from '../shared-utils/types.js';
import { fromOSPathToPosixPath, prettyStringify, simpleGlob } from '../shared-utils/utils.js';

const capitalizeFirstLetter = (s: string): string => s.charAt(0).toUpperCase() + s.slice(1);

export const updateImports = async ({
  packageName,
  packagePath,
  packagePrefix,
}: {
  readonly packageName: string,
  readonly packagePath: string,
  readonly packagePrefix: string;
}) => {
  console.log(`\nUpdating imports for '${packageName}'`);

  const sourcePath = join(packagePath, sourceFolderName);
  const sourceFiles = (
      await simpleGlob({ path: sourcePath, recursive: true, keepFilesOrFolders: 'Files' })
    ).filter(
      ({ name, extension, relativeParentPath }) =>
        javaScriptExtensions.includes(extension)
        && !relativeParentPath.startsWith(internalFolderName)
        && !relativeParentPath.startsWith(binariesFolderName)
        && name !== indexTsFilename,
    );

  console.log(`  Regenerating '${indexTsFilename}'`);
  const indexTsPath = join(sourcePath, indexTsFilename);
  let noIndexTs = false;
  let indexTsContent = '';
  try {
    /* eslint-disable-next-line functional/no-expression-statements */
    indexTsContent = await readFile(indexTsPath, 'utf8');
    /* eslint-disable-next-line functional/no-expression-statements */
    noIndexTs = false;
  } catch (e: unknown) {
    if (e instanceof Error && 'code' in e && e['code'] === 'ENOENT')
      /* eslint-disable-next-line functional/no-expression-statements */
      noIndexTs = true;
    else throw e;
  }
  if (noIndexTs || indexTsContent.startsWith(autoGeneratedFileWarning)) {
    /* eslint-disable-next-line functional/no-expression-statements */
    await writeFile(
      indexTsPath,
      autoGeneratedFileWarning
        + '\n\n'
        + sourceFiles
          // path.join removes upfront './' but typescript requires them so we must add them
          .map(
            ({ bareName, relativeParentPath }) =>
            {
              const pathedName = fromOSPathToPosixPath(join(relativeParentPath, bareName))
              return `export * as ${packagePrefix}${pathedName.split('/').map(capitalizeFirstLetter).join('')} \
              from './${pathedName}.js';`
            }
              
          )
          .join('\n'),
    );
  } else
    throw new Error(`Could not autogenerate '${indexTsFilename}' because the file already exists\
 and does not start with predefined warning comment`);

console.log(`  Regenerating namespace exports in '${packageJsonFilename}'`);
const packageJsonPath = join(sourcePath, indexTsFilename);
/* eslint-disable-next-line functional/no-expression-statements */
const packageJsonContent = await readFile(packageJsonPath, 'utf8');
const packageJson:unknown = JSON.parse(packageJsonContent)

if (!isRecord(packageJson))
  throw new Error(`'${packageJsonFilename}' must represent a record`)

/* eslint-disable-next-line functional/no-expression-statements */
await writeFile(
      packageJsonPath,
      prettyStringify({
        ...packageJson,
        /* import .ts because some tools like node with the --experimental-transform-types flag are not capable of converting .js to .ts*/
        exports: {
          '.': {
            import: `./${sourceFolderName}/index.ts`,
          },
          './tests': {
            import: `./${sourceFolderName}/index.tests.ts`,
          },
          ...Object.fromEntries(sourceFiles.map(
            ({ bareName, relativeParentPath }) =>
            {
              const pathedName = fromOSPathToPosixPath(join(relativeParentPath, bareName))
              return [`./${packagePrefix}${pathedName.split('/').map(capitalizeFirstLetter).join('')}`,
                {
            import: './${pathedName}.ts',
          }
              ]as const
            }
              
          ))
        },
      })
    );

};

