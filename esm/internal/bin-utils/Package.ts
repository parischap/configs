/** Module that represents a Package (see README.md). */
/* This module must not import any external dependency. It must be runnable without a package.json because it is used by the generate-config-files.ts bin */

import { readFile, rm } from 'fs/promises';
import { join } from 'path';
import {
  configFilename,
  foldersWithoutConfigFiles,
  packagesFolderName,
  pnpmLockFilename,
  prodFolderName,
  readMeFilename,
  tsBuildInfoFolderName,
  viteTimeStampFilenamePattern,
} from '../shared-utils/constants.js';
import { isRecord, Record } from '../shared-utils/types.js';
import { readFiles, readFilesRecursively, toMiniGlobRegExp } from '../shared-utils/utils.js';
import * as ConfigFileDescriptor from './ConfigFileDescriptor.js';
import * as PackageFiles from './PackageFiles.js';

/**
 * Module tag
 *
 * @category Module markers
 */
const _moduleTag = '@parischap/configs/internal/bin-utils/Package/';
const _TypeId: unique symbol = Symbol.for(_moduleTag) as _TypeId;
type _TypeId = typeof _TypeId;

// List of files which can be in a package although not generated by the configs package
const filesNotGeneratedByConfigsPackageDefault = toMiniGlobRegExp([
  readMeFilename,
  configFilename,
  viteTimeStampFilenamePattern,
]);

const noSourcePackageConfigFileDecoder = ConfigFileDescriptor.toDecoder(
  ConfigFileDescriptor.noSourcePackage,
);
const sourcePackageConfigFileDecoder = ConfigFileDescriptor.toDecoder(
  ConfigFileDescriptor.sourcePackage,
);
/** Properties shared by all Package's */
interface _Base {
  /** Name of the package */
  readonly name: string;
  /** Absolute path to the package root */
  readonly path: string;
}

/** Internal properties shared by all Package's */
interface _InternalBase {
  /**
   * RegExp that matches files that are allowed to be in the package although not generated by the
   * configs package
   */
  readonly filesNotGeneratedByConfigsPackage: RegExp;
  /** Generates the PackageFiles for `self` */
  readonly toPackageFiles: () => Promise<PackageFiles.Type>;
}

/**
 * Type of a source Package
 *
 * @category Models
 */
type SourceType = OnePackageRepo.Type | SubPackage.Type;

/**
 * Type of a no source Package
 *
 * @category Models
 */
type NoSourceType = TopPackage.Type | MonoRepo.Type;

/**
 * Type of a Package
 *
 * @category Models
 */
export type Type = NoSourceType | SourceType;

/**
 * Returns true if `self` is a source package (see README.md)
 *
 * @category Predicates
 */
export const isSourcePackage = (self: Type): boolean =>
  OnePackageRepo.has(self) || SubPackage.has(self);

/**
 * Returns the name of Package `self`
 *
 * @category Destructors
 */
export const name = (self: Type): string => self.name;

/**
 * Returns the path of Package `self`
 *
 * @category Destructors
 */
export const path = (self: Type): string => self.path;

/**
 * Reads the configuration file of Package `self`
 *
 * @category Destructors
 */
export const readConfigFile = async (self: Type): Promise<Record> => {
  const contents = await readFile(join(self.path, configFilename), 'utf8');

  const configFile: unknown = JSON.parse(contents);

  if (!isRecord(configFile))
    throw new Error(
      `'${configFilename}' must contain the json representation of a non-null object`,
    );
  return configFile;
};

/**
 * Returns an array of all configuration files present in `self`
 *
 * @category Destructors
 */
export const allConfigurationFiles = async (self: Type): Promise<Array<string>> => {
  const { path } = self;

  return [
    ...(
      await readFilesRecursively({
        path,
        foldersToExclude: foldersWithoutConfigFiles,
        dontFailOnInexistentPath: false,
      })
    )
      .map(({ relativePath }) => relativePath)
      .filter((relativePath) => !self.filesNotGeneratedByConfigsPackage.test(relativePath)),
    ...(
      await readFiles({
        path: join(path, packagesFolderName),
        dontFailOnInexistentPath: true,
      })
    ).map((name) => `${packagesFolderName}/${name}`),
  ];
};

/** Cleans prod directories of `self` */
export const cleanProd = async (self: Type): Promise<void> => {
  const { path } = self;
  /* eslint-disable-next-line functional/no-expression-statements*/
  await rm(join(path, prodFolderName), { force: true, recursive: true });
  /* eslint-disable-next-line functional/no-expression-statements*/
  await rm(join(path, tsBuildInfoFolderName), { force: true, recursive: true });
};

/**
 * Generates the PackageFiles for `self`
 *
 * @categrory Destructors
 */
export const toPackageFiles = (self: Type): Promise<PackageFiles.Type> => self.toPackageFiles();

/**
 * Namespace of a TopPackage
 *
 * @category Models
 */
export namespace TopPackage {
  const _namespaceTag = _moduleTag + 'TopPackage/';
  const _TypeId: unique symbol = Symbol.for(_namespaceTag) as _TypeId;
  type _TypeId = typeof _TypeId;

  /**
   * Type of a TopPackage
   *
   * @category Models
   */
  export interface Type extends _Base, _InternalBase {
    /** Array of the names of all the source packages of the Project whose TopPackage is `self` */
    readonly allSourcePackages: ReadonlyArray<string>;
    /** Array of the paths to all the packages of the Project whose TopPackage is `self` */
    readonly allPackagesPaths: ReadonlyArray<string>;
    /** @internal */
    readonly [_TypeId]: _TypeId;
  }

  /**
   * Type guard
   *
   * @category Guards
   */
  export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

  /** _prototype */
  const _proto = {
    [_TypeId]: _TypeId,
    filesNotGeneratedByConfigsPackage: toMiniGlobRegExp([readMeFilename, pnpmLockFilename]),
    toPackageFiles(this: Type): Promise<PackageFiles.Type> {
      return Promise.resolve(
        PackageFiles.topPackage({
          ...this,
          description: 'Top repo of my developments',
          linkedPackage: this,
        }),
      );
    },
  };

  /**
   * Constructor
   *
   * @category Constructors
   */
  export const make = (
    data: _Base & {
      readonly allSourcePackages: ReadonlyArray<string>;
      readonly allPackagesPaths: ReadonlyArray<string>;
    },
  ): Type => Object.assign(Object.create(_proto), data) as never;
}

/**
 * Namespace of a MonoRepo
 *
 * @category Models
 */
export namespace MonoRepo {
  const _namespaceTag = _moduleTag + 'MonoRepo/';
  const _TypeId: unique symbol = Symbol.for(_namespaceTag) as _TypeId;
  type _TypeId = typeof _TypeId;

  /**
   * Type of a MonoRepo
   *
   * @category Models
   */
  export interface Type extends _Base, _InternalBase {
    /** @internal */
    readonly [_TypeId]: _TypeId;
  }

  /**
   * Type guard
   *
   * @category Guards
   */
  export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

  /** _prototype */
  const _proto = {
    [_TypeId]: _TypeId,
    filesNotGeneratedByConfigsPackage: filesNotGeneratedByConfigsPackageDefault,
    async toPackageFiles(this: Type): Promise<PackageFiles.Type> {
      const configurationFileObject = await readConfigFile(this);
      const configFileParams = noSourcePackageConfigFileDecoder(configurationFileObject);
      for (const warning of configFileParams.warnings)
        console.log(`Package '${this.name}': ${warning}`);
      return PackageFiles.monorepo({
        ...this,
        ...configFileParams,
        linkedPackage: this,
      });
    },
  };

  /**
   * Constructor
   *
   * @category Constructors
   */
  export const make = (data: _Base): Type => Object.assign(Object.create(_proto), data) as never;
}

/**
 * Namespace of a OnePackageRepo
 *
 * @category Models
 */
export namespace OnePackageRepo {
  const _namespaceTag = _moduleTag + 'OnePackageRepo/';
  const _TypeId: unique symbol = Symbol.for(_namespaceTag) as _TypeId;
  type _TypeId = typeof _TypeId;

  /**
   * Type of a OnePackageRepo
   *
   * @category Models
   */
  export interface Type extends _Base, _InternalBase {
    /** Flag that indicates if `self` is the configs package */
    readonly isConfigsPackage: boolean;
    /** @internal */
    readonly [_TypeId]: _TypeId;
  }

  /**
   * Type guard
   *
   * @category Guards
   */
  export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

  /** _prototype */
  const _proto = {
    [_TypeId]: _TypeId,
    filesNotGeneratedByConfigsPackage: filesNotGeneratedByConfigsPackageDefault,
    async toPackageFiles(this: Type): Promise<PackageFiles.Type> {
      const configurationFileObject = await readConfigFile(this);
      const configFileParams = sourcePackageConfigFileDecoder(configurationFileObject);
      for (const warning of configFileParams.warnings)
        console.log(`Package '${this.name}': ${warning}`);
      /* We need to keep the original extensions for prettier that uses node with the `--experimental-transform-types` flag to read its configuration file when it has a `.ts` extension. Now node is unable to transform `.js` extensions into `.ts` extensions as TypeScript does */
      const keepFileExtensions = OnePackageRepo.has(self) && self.isConfigsPackage;
      const importsParams = await generateExports(this, configFileParams.packagePrefix);
      return PackageFiles.onePackageRepo({
        ...this,
        ...configFileParams,
        ...importsParams,
        linkedPackage: this,
      });
    },
  };

  /**
   * Constructor
   *
   * @category Constructors
   */
  export const make = (data: _Base & { readonly isConfigsPackage: boolean }): Type =>
    Object.assign(Object.create(_proto), data) as never;
}

/**
 * Namespace of aSubPackage
 *
 * @category Models
 */
export namespace SubPackage {
  const _namespaceTag = _moduleTag + 'SubPackage/';
  const _TypeId: unique symbol = Symbol.for(_namespaceTag) as _TypeId;
  type _TypeId = typeof _TypeId;

  /**
   * Type of a SunPacakage
   *
   * @category Models
   */
  export interface Type extends _Base, _InternalBase {
    /** Name of the parent MonoRepo of `self` */
    readonly parentName: string;
    /** @internal */
    readonly [_TypeId]: _TypeId;
  }

  /**
   * Type guard
   *
   * @category Guards
   */
  export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

  /** _prototype */
  const _proto = {
    [_TypeId]: _TypeId,
    filesNotGeneratedByConfigsPackage: filesNotGeneratedByConfigsPackageDefault,
    async toPackageFiles(this: Type): Promise<PackageFiles.Type> {
      const configurationFileObject = await readConfigFile(this);
      const configFileParams = sourcePackageConfigFileDecoder(configurationFileObject);
      for (const warning of configFileParams.warnings)
        console.log(`Package '${this.name}': ${warning}`);
      const importsParams = await generateExports(this, configFileParams.packagePrefix);
      return PackageFiles.subPackage({
        ...this,
        ...configFileParams,
        ...importsParams,
        linkedPackage: this,
      });
    },
  };

  /**
   * Constructor
   *
   * @category Constructors
   */
  export const make = (data: _Base & { readonly parentName: string }): Type =>
    Object.assign(Object.create(_proto), data) as never;
}
