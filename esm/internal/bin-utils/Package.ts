/** Module that represents a Package (see ReadMe.md). */
// This module must not import any external dependency. It must be runnable without a package.json

import { readFile, rm } from 'fs/promises';
import { join } from 'path';
import {
  binariesFolderName,
  configFilename,
  foldersWithoutConfigFiles,
  indexTsFilename,
  internalFolderName,
  javaScriptExtensions,
  packagesFolderName,
  pnpmLockFilename,
  prodFolderName,
  readMeFilename,
  sourceFolderName,
  tsBuildInfoFolderName,
  viteTimeStampFilenamePattern,
} from '../shared-utils/constants.js';
import { isRecord, Record } from '../shared-utils/types.js';
import {
  capitalizeFirstLetter,
  fromOSPathToPosixPath,
  readFiles,
  readFilesRecursively,
  toMiniGlobRegExp,
} from '../shared-utils/utils.js';
import * as ConfigFileDescriptor from './ConfigFileDescriptor.js';
import * as PackageFiles from './PackageFiles.js';

/**
 * Module tag
 *
 * @category Module markers
 */
const _moduleTag = '@parischap/configs/internal/bin-utils/Package/';
const _TypeId: unique symbol = Symbol.for(_moduleTag) as _TypeId;
type _TypeId = typeof _TypeId;

// List of files which can be in a package although not generated by the configs package
const filesNotGeneratedByConfigsPackageDefault = toMiniGlobRegExp([
  readMeFilename,
  configFilename,
  viteTimeStampFilenamePattern,
]);

const noSourcePackageConfigFileDecoder = ConfigFileDescriptor.toDecoder(
  ConfigFileDescriptor.noSourcePackage,
);
const sourcePackageConfigFileDecoder = ConfigFileDescriptor.toDecoder(
  ConfigFileDescriptor.sourcePackage,
);
/** Properties shared by all Package's */
interface _Base {
  /** Name of the package */
  readonly name: string;
  /** Absolute path to the package root */
  readonly path: string;
}

/** Internal properties shared by all Package's */
interface _InternalBase {
  /**
   * RegExp that matches files that are allowed to be in the package although not generated by the
   * configs package
   */
  readonly filesNotGeneratedByConfigsPackage: RegExp;
  /** Generates the PackageFiles for `self` */
  toPackageFiles(): Promise<PackageFiles.Type>;
}

/**
 * Type of a source Package
 *
 * @category Models
 */
type SourceType = OnePackageRepo.Type | SubPackage.Type;

/**
 * Type of a no source Package
 *
 * @category Models
 */
type NoSourceType = TopPackage.Type | MonoRepo.Type;

/**
 * Type of a Package
 *
 * @category Models
 */
export type Type = NoSourceType | SourceType;

/**
 * Returns true if `self` is a source package (see ReadMe.md)
 *
 * @category Predicates
 */
export const isSourcePackage = (self: Type): boolean =>
  OnePackageRepo.has(self) || SubPackage.has(self);

/**
 * Returns the name of Package `self`
 *
 * @category Destructors
 */
export const name = (self: Type): string => self.name;

/**
 * Returns the path of Package `self`
 *
 * @category Destructors
 */
export const path = (self: Type): string => self.path;

/**
 * Reads the configuration file of Package `self`
 *
 * @category Destructors
 */
export const readConfigFile = async (self: Type): Promise<Record> => {
  const contents = await readFile(join(self.path, configFilename), 'utf8');

  const configFile: unknown = JSON.parse(contents);

  if (!isRecord(configFile))
    throw new Error(
      `'${configFilename}' must contain the json representation of a non-null object`,
    );
  return configFile;
};

/**
 * Reads the contents of the source directory of `self`. Produces the contents of the index.ts file
 * and of the exports field of the `package.json` (namespace exports)
 *
 * @category Destructors
 */
export const generateImports = async (
  self: SourceType,
  packagePrefix: string,
): Promise<{ indexTsContents: string; packageJsonExports: Record }> => {
  const basePackageJsonExports = {
    '.': {
      import: `./${sourceFolderName}/index.js`,
    },
    './tests': {
      import: `./${sourceFolderName}/index.tests.js`,
    },
  };

  if (packagePrefix === '')
    return { indexTsContents: '', packageJsonExports: basePackageJsonExports };
  const keepFileExtensions = OnePackageRepo.has(self) && self.isConfigsPackage;
  const sourceFiles = (
    await readFilesRecursively({
      path: join(self.path, sourceFolderName),
      foldersToExclude: [internalFolderName, binariesFolderName],
      dontFailOnInexistentPath: false,
    })
  )
    .filter(
      ({ extension, name }) => name !== indexTsFilename && javaScriptExtensions.includes(extension),
    )
    .map(({ bareName, relativeParentPath, extension }) => {
      const barePath = fromOSPathToPosixPath(join(relativeParentPath, bareName));
      return {
        namespaceExportName: `./${packagePrefix}${barePath.split('/').map(capitalizeFirstLetter).join('')}`,
        exportPath: `./${barePath}.${keepFileExtensions ? extension : 'js'}`,
      };
    });

  return {
    indexTsContents: sourceFiles
      // path.join removes upfront './' but typescript requires them so we must add them
      .map(
        ({ exportPath, namespaceExportName }) =>
          `export * as ${namespaceExportName} from '${exportPath}';`,
      )
      .join('\n'),
    packageJsonExports: {
      ...Object.fromEntries(
        sourceFiles.map(({ exportPath, namespaceExportName }) => {
          return [
            `./${namespaceExportName}`,
            {
              import: exportPath,
            },
          ] as const;
        }),
      ),
      ...basePackageJsonExports,
    },
  };
};

/**
 * Returns an array of all configuration files present in `self`
 *
 * @category Destructors
 */
export const allConfigurationFiles = async (self: Type): Promise<Array<string>> => {
  const { path } = self;

  return [
    ...(
      await readFilesRecursively({
        path,
        foldersToExclude: foldersWithoutConfigFiles,
        dontFailOnInexistentPath: false,
      })
    )
      .map(({ relativePath }) => relativePath)
      .filter((relativePath) => !self.filesNotGeneratedByConfigsPackage.test(relativePath)),
    ...(
      await readFiles({
        path: join(path, packagesFolderName),
        dontFailOnInexistentPath: true,
      })
    ).map((name) => `${packagesFolderName}/${name}`),
  ];
};

/** Cleans prod directories of `self` */
export const cleanProd = async (self: Type): Promise<void> => {
  const { path } = self;
  /* eslint-disable-next-line functional/no-expression-statements*/
  await rm(join(path, prodFolderName), { force: true, recursive: true });
  /* eslint-disable-next-line functional/no-expression-statements*/
  await rm(join(path, tsBuildInfoFolderName), { force: true, recursive: true });
};

/**
 * Generates the PackageFiles for `self`
 *
 * @categrory Destructors
 */
export const toPackageFiles = (self: Type): Promise<PackageFiles.Type> => self.toPackageFiles();

/**
 * Namespace of a TopPackage
 *
 * @category Models
 */
export namespace TopPackage {
  const _namespaceTag = _moduleTag + 'TopPackage/';
  const _TypeId: unique symbol = Symbol.for(_namespaceTag) as _TypeId;
  type _TypeId = typeof _TypeId;

  /**
   * Type of a TopPackage
   *
   * @category Models
   */
  export interface Type extends _Base, _InternalBase {
    /** Array of the names of all the source packages of the Project whose TopPackage is `self` */
    readonly allSourcePackages: ReadonlyArray<string>;
    /** Array of the paths to all the packages of the Project whose TopPackage is `self` */
    readonly allPackagesPaths: ReadonlyArray<string>;
    /** @internal */
    readonly [_TypeId]: _TypeId;
  }

  /**
   * Type guard
   *
   * @category Guards
   */
  export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

  /** _prototype */
  const _proto = {
    [_TypeId]: _TypeId,
    filesNotGeneratedByConfigsPackage: toMiniGlobRegExp([readMeFilename, pnpmLockFilename]),
    async toPackageFiles(this: Type): Promise<PackageFiles.Type> {
      return PackageFiles.topPackage({
        ...this,
        description: 'Top repo of my developments',
        linkedPackage: this,
      });
    },
  };

  /**
   * Constructor
   *
   * @category Constructors
   */
  export const make = (
    data: _Base & {
      readonly allSourcePackages: ReadonlyArray<string>;
      readonly allPackagesPaths: ReadonlyArray<string>;
    },
  ): Type => Object.assign(Object.create(_proto), data);
}

/**
 * Namespace of a MonoRepo
 *
 * @category Models
 */
export namespace MonoRepo {
  const _namespaceTag = _moduleTag + 'MonoRepo/';
  const _TypeId: unique symbol = Symbol.for(_namespaceTag) as _TypeId;
  type _TypeId = typeof _TypeId;

  /**
   * Type of a MonoRepo
   *
   * @category Models
   */
  export interface Type extends _Base, _InternalBase {
    /** @internal */
    readonly [_TypeId]: _TypeId;
  }

  /**
   * Type guard
   *
   * @category Guards
   */
  export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

  /** _prototype */
  const _proto = {
    [_TypeId]: _TypeId,
    filesNotGeneratedByConfigsPackage: filesNotGeneratedByConfigsPackageDefault,
    async toPackageFiles(this: Type): Promise<PackageFiles.Type> {
      const configurationFileObject = await readConfigFile(this);
      const configFileParams = noSourcePackageConfigFileDecoder(configurationFileObject);
      for (const warning of configFileParams.warnings)
        console.log(`Package '${this.name}': ${warning}`);
      return PackageFiles.monorepo({
        ...this,
        ...configFileParams,
        linkedPackage: this,
      });
    },
  };

  /**
   * Constructor
   *
   * @category Constructors
   */
  export const make = (data: _Base): Type => Object.assign(Object.create(_proto), data);
}

/**
 * Namespace of a OnePackageRepo
 *
 * @category Models
 */
export namespace OnePackageRepo {
  const _namespaceTag = _moduleTag + 'OnePackageRepo/';
  const _TypeId: unique symbol = Symbol.for(_namespaceTag) as _TypeId;
  type _TypeId = typeof _TypeId;

  /**
   * Type of a OnePackageRepo
   *
   * @category Models
   */
  export interface Type extends _Base, _InternalBase {
    /** Flag that indicates if `self` is the configs package */
    readonly isConfigsPackage: boolean;
    /** @internal */
    readonly [_TypeId]: _TypeId;
  }

  /**
   * Type guard
   *
   * @category Guards
   */
  export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

  /** _prototype */
  const _proto = {
    [_TypeId]: _TypeId,
    filesNotGeneratedByConfigsPackage: filesNotGeneratedByConfigsPackageDefault,
    async toPackageFiles(this: Type): Promise<PackageFiles.Type> {
      const configurationFileObject = await readConfigFile(this);
      const configFileParams = sourcePackageConfigFileDecoder(configurationFileObject);
      for (const warning of configFileParams.warnings)
        console.log(`Package '${this.name}': ${warning}`);
      const importsParams = await generateImports(this, configFileParams.packagePrefix);
      return PackageFiles.onePackageRepo({
        ...this,
        ...configFileParams,
        ...importsParams,
        linkedPackage: this,
      });
    },
  };

  /**
   * Constructor
   *
   * @category Constructors
   */
  export const make = (data: _Base & { readonly isConfigsPackage: boolean }): Type =>
    Object.assign(Object.create(_proto), data);
}

/**
 * Namespace of aSubPackage
 *
 * @category Models
 */
export namespace SubPackage {
  const _namespaceTag = _moduleTag + 'SubPackage/';
  const _TypeId: unique symbol = Symbol.for(_namespaceTag) as _TypeId;
  type _TypeId = typeof _TypeId;

  /**
   * Type of a SunPacakage
   *
   * @category Models
   */
  export interface Type extends _Base, _InternalBase {
    /** Name of the parent MonoRepo of `self` */
    readonly parentName: string;
    /** @internal */
    readonly [_TypeId]: _TypeId;
  }

  /**
   * Type guard
   *
   * @category Guards
   */
  export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

  /** _prototype */
  const _proto = {
    [_TypeId]: _TypeId,
    filesNotGeneratedByConfigsPackage: filesNotGeneratedByConfigsPackageDefault,
    async toPackageFiles(this: Type): Promise<PackageFiles.Type> {
      const configurationFileObject = await readConfigFile(this);
      const configFileParams = sourcePackageConfigFileDecoder(configurationFileObject);
      for (const warning of configFileParams.warnings)
        console.log(`Package '${this.name}': ${warning}`);
      const importsParams = await generateImports(this, configFileParams.packagePrefix);
      return PackageFiles.subPackage({
        ...this,
        ...configFileParams,
        ...importsParams,
        linkedPackage: this,
      });
    },
  };

  /**
   * Constructor
   *
   * @category Constructors
   */
  export const make = (data: _Base & { readonly parentName: string }): Type =>
    Object.assign(Object.create(_proto), data);
}
