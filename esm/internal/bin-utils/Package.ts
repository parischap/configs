/** Module that represents a Package (see ReadMe.md). */
// This module must not import any external dependency. It must be runnable without a package.json

import { mkdir, readFile, rm } from 'fs/promises';
import { dirname, extname, join } from 'path';
import {
  binariesFolderName,
  configFilename,
  foldersWithoutConfigFiles,
  indexTsFilename,
  internalFolderName,
  javaScriptExtensions,
  packagesFolderName,
  pnpmLockFilename,
  prodFolderName,
  readMeFilename,
  sourceFolderName,
  tsBuildInfoFolderName,
  viteTimeStampFilenamePattern,
} from '../shared-utils/constants.js';
import { isRecord, Record } from '../shared-utils/types.js';
import {
  capitalizeFirstLetter,
  fromOSPathToPosixPath,
  fromPosixPathToOSPath,
  prettyStringify,
  readFiles,
  readFilesRecursively,
  toMiniGlobRegExp,
  writeAutogeneratedFile,
} from '../shared-utils/utils.js';
import * as ConfigFileDescriptor from './ConfigFileDescriptor.js';
import * as PackageFiles from './PackageFiles.js';

/**
 * Module tag
 *
 * @category Module markers
 */
const _moduleTag = '@parischap/configs/Package/';
const _TypeId: unique symbol = Symbol.for(_moduleTag) as _TypeId;
type _TypeId = typeof _TypeId;

// List of files which can be in a package although not generated by the configs package
const filesNotGeneratedByConfigsPackageDefault = toMiniGlobRegExp([
  readMeFilename,
  configFilename,
  viteTimeStampFilenamePattern,
]);

const noSourcePackageConfigFileDecoder = ConfigFileDescriptor.toDecoder(
  ConfigFileDescriptor.noSourcePackage,
);
const sourcePackageConfigFileDecoder = ConfigFileDescriptor.toDecoder(
  ConfigFileDescriptor.sourcePackage,
);
/** Properties shared by all Package's */
interface _Base {
  /** Name of the package */
  readonly name: string;
  /** Absolute path to the package root */
  readonly path: string;
}

/** Internal properties shared by all Package's */
interface _InternalBase {
  /** Tag that prefixes all messages and errors */
  readonly tag: string;
  /**
   * RegExp that matches files that are allowed to be in the package although not generated by the
   * configs package
   */
  readonly filesNotGeneratedByConfigsPackage: RegExp;
  /** Generates the PackageFiles for `self` */
  toPackageFiles(): Promise<PackageFiles.Type>;
}

/**
 * Type of a source Package
 *
 * @category Models
 */
type SourceType = OnePackageRepo.Type | SubPackage.Type;

/**
 * Type of a no source Package
 *
 * @category Models
 */
type NoSourceType = TopPackage.Type | MonoRepo.Type;

/**
 * Type of a Package
 *
 * @category Models
 */
export type Type = NoSourceType | SourceType;

/**
 * Returns true if `self` is a source package (see ReadMe.md)
 *
 * @category Predicates
 */
export const isSourcePackage = (self: Type): boolean =>
  OnePackageRepo.has(self) || SubPackage.has(self);

/**
 * Returns the name of Package `self`
 *
 * @category Destructors
 */
export const name = (self: Type): string => self.name;

/**
 * Returns the path of Package `self`
 *
 * @category Destructors
 */
export const path = (self: Type): string => self.path;

/**
 * Reads the configuration file of Package `self`
 *
 * @category Destructors
 */
export const readConfigFile = async (self: Type): Promise<Record> => {
  console.log(`${self.tag}reading configuration file`);

  const contents = await readFile(join(self.path, configFilename), 'utf8');

  const configFile: unknown = JSON.parse(contents);

  if (!isRecord(configFile))
    throw new Error(
      `${self.tag}'${configFilename}' must contain the json representation of a non-null object`,
    );
  return configFile;
};

/**
 * Reads the contents of the source directory of `self`. Produces the contents of the index.ts file
 * and of the exports field of the `package.json` (namespace exports)
 *
 * @category Destructors
 */
export const generateImports = async (
  self: SourceType,
  packagePrefix: string,
): Promise<{ indexTsContents: string; packageJsonExports: Record }> => {
  const basePackageJsonExports = {
    '.': {
      import: `./${sourceFolderName}/index.js`,
    },
    './tests': {
      import: `./${sourceFolderName}/index.tests.js`,
    },
  };

  if (packagePrefix === '')
    return { indexTsContents: '', packageJsonExports: basePackageJsonExports };
  const keepFileExtensions = OnePackageRepo.has(self) && self.isConfigsPackage;
  const sourceFiles = (
    await readFilesRecursively({
      path: join(self.path, sourceFolderName),
      foldersToExclude: [internalFolderName, binariesFolderName],
      dontFailOnInexistentPath: false,
    })
  )
    .filter(
      ({ extension, name }) => name !== indexTsFilename && javaScriptExtensions.includes(extension),
    )
    .map(({ bareName, relativeParentPath, extension }) => {
      const barePath = fromOSPathToPosixPath(join(relativeParentPath, bareName));
      return {
        namespaceExportName: `./${packagePrefix}${barePath.split('/').map(capitalizeFirstLetter).join('')}`,
        exportPath: `./${barePath}.${keepFileExtensions ? extension : 'js'}`,
      };
    });

  return {
    indexTsContents: sourceFiles
      // path.join removes upfront './' but typescript requires them so we must add them
      .map(
        ({ exportPath, namespaceExportName }) =>
          `export * as ${namespaceExportName} from '${exportPath}';`,
      )
      .join('\n'),
    packageJsonExports: {
      ...Object.fromEntries(
        sourceFiles.map(({ exportPath, namespaceExportName }) => {
          return [
            `./${namespaceExportName}`,
            {
              import: exportPath,
            },
          ] as const;
        }),
      ),
      ...basePackageJsonExports,
    },
  };
};

/**
 * Returns a checker that verifies that all configuration files present in `self` are generated by
 * the configs package or belong to the list `filesNotGeneratedByConfigsPackage`.
 *
 * @category Destructors
 */
export const toUselessFilesChecker = (
  self: Type,
): ((packageFiles: PackageFiles.Type) => Promise<void>) => {
  const { path, tag } = self;
  return async (packageFiles) => {
    console.log(`${tag}determining potential useless files`);

    // In project.config.ts, paths are posix-Style. Let's convert them to OS style
    const filesToCreate = Object.keys(packageFiles).map(fromPosixPathToOSPath);

    const currentFiles = await readFilesRecursively({
      path,
      foldersToExclude: foldersWithoutConfigFiles,
      dontFailOnInexistentPath: false,
    });

    const unexpectedConfigFiles = [
      ...currentFiles
        .filter(
          ({ relativePath }) =>
            !filesToCreate.includes(relativePath)
            && !self.filesNotGeneratedByConfigsPackage.test(relativePath),
        )
        .map(({ relativePath }) => relativePath),
      ...(
        await readFiles({
          path: join(path, packagesFolderName),
          dontFailOnInexistentPath: true,
        })
      ).map((name) => `${packagesFolderName}/${name}`),
    ];

    if (unexpectedConfigFiles.length > 0)
      throw new Error(
        `${tag}following unexpected files where found in the package:\n${unexpectedConfigFiles.join(',\n')}`,
      );
  };
};

/**
 * Returns a function that takes configuration files and saves them in self
 *
 * @category Destructors
 */
export const toPackageFileSaver = (
  self: Type,
): ((packageFiles: PackageFiles.Type) => Promise<void>) => {
  const { path, tag } = self;
  return async (packageFiles) => {
    console.log(`${tag}writing configuration files`);
    for (const [filename, fileContent] of Object.entries(packageFiles)) {
      const contentToWriteFunc =
        extname(filename) === '.json' ? () => prettyStringify(fileContent)
        : typeof fileContent === 'string' ? () => fileContent
        : () => {
            throw new Error(
              `${tag}entry '${filename}' in '${configFilename}' must have value of type string`,
            );
          };

      const targetFilename = join(path, filename);
      // Create directory in case it does not exist
      /* eslint-disable-next-line functional/no-expression-statements*/
      await mkdir(dirname(targetFilename), { recursive: true });

      /* eslint-disable-next-line functional/no-expression-statements*/
      await writeAutogeneratedFile({ path: targetFilename, newContents: contentToWriteFunc() });
    }
  };
};

/** Cleans prod directories of `self` */
export const cleanProd = async (self: Type): Promise<void> => {
  const { path, tag } = self;
  console.log(`${tag}cleaning prod directories`);
  /* eslint-disable-next-line functional/no-expression-statements*/
  await rm(join(path, prodFolderName), { force: true, recursive: true });
  /* eslint-disable-next-line functional/no-expression-statements*/
  await rm(join(path, tsBuildInfoFolderName), { force: true, recursive: true });
};

/**
 * Generates the PackageFiles for `self`
 *
 * @categrory Destructors
 */
export const toPackageFiles = (self: Type): Promise<PackageFiles.Type> => self.toPackageFiles();

/**
 * Namespace of a TopPackage
 *
 * @category Models
 */
export namespace TopPackage {
  const _namespaceTag = _moduleTag + 'TopPackage/';
  const _TypeId: unique symbol = Symbol.for(_namespaceTag) as _TypeId;
  type _TypeId = typeof _TypeId;

  /**
   * Type of a TopPackage
   *
   * @category Models
   */
  export interface Type extends _Base, _InternalBase {
    /** Array of the names of all the source packages of the Project whose TopPackage is `self` */
    readonly allSourcePackages: ReadonlyArray<string>;
    /** Array of the paths to all the packages of the Project whose TopPackage is `self` */
    readonly allPackagesPaths: ReadonlyArray<string>;
    /** @internal */
    readonly [_TypeId]: _TypeId;
  }

  /**
   * Type guard
   *
   * @category Guards
   */
  export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

  /** _prototype */
  const _proto = {
    [_TypeId]: _TypeId,
    filesNotGeneratedByConfigsPackage: toMiniGlobRegExp([readMeFilename, pnpmLockFilename]),
    async toPackageFiles(this: Type): Promise<PackageFiles.Type> {
      console.log(`${this.tag}generating package files for top package`);
      return PackageFiles.topPackage({
        ...this,
        description: 'Top repo of my developments',
      });
    },
  };

  /**
   * Constructor
   *
   * @category Constructors
   */
  export const make = (
    data: _Base & {
      readonly allSourcePackages: ReadonlyArray<string>;
      readonly allPackagesPaths: ReadonlyArray<string>;
    },
  ): Type => Object.assign(Object.create(_proto), { ...data, tag: `'${data.name}': ` });
}

/**
 * Namespace of a MonoRepo
 *
 * @category Models
 */
export namespace MonoRepo {
  const _namespaceTag = _moduleTag + 'MonoRepo/';
  const _TypeId: unique symbol = Symbol.for(_namespaceTag) as _TypeId;
  type _TypeId = typeof _TypeId;

  /**
   * Type of a MonoRepo
   *
   * @category Models
   */
  export interface Type extends _Base, _InternalBase {
    /** @internal */
    readonly [_TypeId]: _TypeId;
  }

  /**
   * Type guard
   *
   * @category Guards
   */
  export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

  /** _prototype */
  const _proto = {
    [_TypeId]: _TypeId,
    filesNotGeneratedByConfigsPackage: filesNotGeneratedByConfigsPackageDefault,
    async toPackageFiles(this: Type): Promise<PackageFiles.Type> {
      console.log(`${this.tag}generating package files for monorepo`);
      const configurationFileObject = await readConfigFile(this);
      const configFileParams = noSourcePackageConfigFileDecoder({
        configurationFileObject,
        tag: this.tag,
      });

      return PackageFiles.monorepo({
        ...this,
        ...configFileParams,
      });
    },
  };

  /**
   * Constructor
   *
   * @category Constructors
   */
  export const make = (data: _Base): Type =>
    Object.assign(Object.create(_proto), { ...data, tag: `'  ${data.name}': ` });
}

/**
 * Namespace of a OnePackageRepo
 *
 * @category Models
 */
export namespace OnePackageRepo {
  const _namespaceTag = _moduleTag + 'OnePackageRepo/';
  const _TypeId: unique symbol = Symbol.for(_namespaceTag) as _TypeId;
  type _TypeId = typeof _TypeId;

  /**
   * Type of a OnePackageRepo
   *
   * @category Models
   */
  export interface Type extends _Base, _InternalBase {
    /** Flag that indicates if `self` is the configs package */
    readonly isConfigsPackage: boolean;
    /** @internal */
    readonly [_TypeId]: _TypeId;
  }

  /**
   * Type guard
   *
   * @category Guards
   */
  export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

  /** _prototype */
  const _proto = {
    [_TypeId]: _TypeId,
    filesNotGeneratedByConfigsPackage: filesNotGeneratedByConfigsPackageDefault,
    async toPackageFiles(this: Type): Promise<PackageFiles.Type> {
      console.log(`${this.tag}generating package files for one-package repo`);
      const configurationFileObject = await readConfigFile(this);
      const configFileParams = sourcePackageConfigFileDecoder({
        configurationFileObject,
        tag: this.tag,
      });
      const importsParams = await generateImports(this, configFileParams.packagePrefix);
      return PackageFiles.onePackageRepo({
        ...this,
        ...configFileParams,
        ...importsParams,
      });
    },
  };

  /**
   * Constructor
   *
   * @category Constructors
   */
  export const make = (data: _Base & { readonly isConfigsPackage: boolean }): Type =>
    Object.assign(Object.create(_proto), { ...data, tag: `'  ${data.name}': ` });
}

/**
 * Namespace of aSubPackage
 *
 * @category Models
 */
export namespace SubPackage {
  const _namespaceTag = _moduleTag + 'SubPackage/';
  const _TypeId: unique symbol = Symbol.for(_namespaceTag) as _TypeId;
  type _TypeId = typeof _TypeId;

  /**
   * Type of a SunPacakage
   *
   * @category Models
   */
  export interface Type extends _Base, _InternalBase {
    /** Name of the parent MonoRepo of `self` */
    readonly parentName: string;
    /** @internal */
    readonly [_TypeId]: _TypeId;
  }

  /**
   * Type guard
   *
   * @category Guards
   */
  export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

  /** _prototype */
  const _proto = {
    [_TypeId]: _TypeId,
    filesNotGeneratedByConfigsPackage: filesNotGeneratedByConfigsPackageDefault,
    async toPackageFiles(this: Type): Promise<PackageFiles.Type> {
      console.log(`${this.tag}generating package files for sub package`);
      const configurationFileObject = await readConfigFile(this);
      const configFileParams = sourcePackageConfigFileDecoder({
        configurationFileObject,
        tag: this.tag,
      });
      const importsParams = await generateImports(this, configFileParams.packagePrefix);
      return PackageFiles.subPackage({
        ...this,
        ...configFileParams,
        ...importsParams,
      });
    },
  };

  /**
   * Constructor
   *
   * @category Constructors
   */
  export const make = (data: _Base & { readonly parentName: string }): Type =>
    Object.assign(Object.create(_proto), { ...data, tag: `'    ${data.name}': ` });
}
