// This module must not import any external dependency. It must be runnable without a package.json
import { readFileSync } from 'node:fs';
import {
  baseDevDependencies,
  binariesPath,
  commonJsFolderName,
  configsPackageName,
  configsPeerDependencies,
  docsConfigYmlFilename,
  docsFolderName,
  docsIndexMdFilename,
  effectDependencies,
  eslintConfigFilename,
  filesGeneratedByThirdParties,
  foldersGeneratedByThirdParties,
  foldersWithoutConfigFiles,
  githubFolderName,
  githubWorkflowsPagesFilename,
  githubWorkflowsPublishFilename,
  gitIgnoreFilename,
  othersFolderName,
  othersMark,
  owner,
  packageJsonFilename,
  packageManager,
  packagesFolderName,
  prettierConfigFilename,
  prettierIgnoreFilename,
  prodFolderName,
  slashedScope,
  sourceFolderName,
  tsBuildInfoFolderName,
  tsConfigBaseFilename,
  tsConfigFilename,
  tsConfigSrcFilename,
  typesFolderName,
  versionControlService,
  viteConfigFilename,
  vitestConfigFilename,
  workflowsFolderName,
} from '../shared-utils/constants.js';
import type { ReadonlyRecord, StringArray, StringRecord } from '../shared-utils/types.js';
import { deepMerge } from '../shared-utils/utils.js';

export interface CodePackageConfigParameters {
  readonly description: string;
  readonly dependencies: Readonly<StringRecord>;
  readonly devDependencies: Readonly<StringRecord>;
  readonly peerDependencies: Readonly<StringRecord>;
  readonly examples: Readonly<StringArray>;
  readonly scripts: Readonly<StringRecord>;
  readonly environment: string;
  readonly buildMethod: string;
  readonly isPublished: boolean;
  readonly hasDocGen: boolean;
  readonly keywords: Readonly<StringArray>;
  readonly useEffectAsPeerDependency: boolean;
  readonly useEffectPlatform: string;
  readonly packagePrefix: string;
  readonly autogeneratedIndexTs: string;
  readonly autogeneratedImports: ReadonlyRecord;
}

const PRETTIER_CONFIG = `import { prettierConfig } from '@parischap/configs';
export default prettierConfig`;

const PRETTIER_IGNORE: string = [
  ...foldersGeneratedByThirdParties.map((folderName) => `/${folderName}/`),
  ...filesGeneratedByThirdParties.map((fileName) => `/${fileName}`),
].join('\n');

const ESLINT_CONFIG_OTHERS = `import { eslintConfig } from '@parischap/configs';
export default eslintConfig.plainEslintConfig({tsconfigRootDir:import.meta.dirname})`;

const TSCONFIG_BASE: ReadonlyRecord = {
  $schema: 'https://json.schemastore.org/tsconfig',
  _version: '20.1.0',
  extends: ['@tsconfig/strictest/tsconfig.json'],
  compilerOptions: {
    moduleDetection: 'force',
    composite: true,
    resolveJsonModule: true,
    esModuleInterop: false,
    declaration: true,
    skipLibCheck: true,
    emitDecoratorMetadata: true,
    experimentalDecorators: true,
    moduleResolution: 'NodeNext',
    isolatedModules: true,
    sourceMap: true,
    declarationMap: true,
    noEmitOnError: false,
    noErrorTruncation: true,
    // This will be used only when transpiling libraries which might get used in older browsers
    target: 'ES2022',
    module: 'NodeNext',
    incremental: true,
    removeComments: false,
    stripInternal: true,
    lib: ['ESNext'],
    types: ['node'],
    allowJs: true,
    checkJs: true,
    noEmit: true,
    plugins: [
      {
        name: '@effect/language-service',
      },
    ],
    tsBuildInfoFile: `${tsBuildInfoFolderName}/project.tsbuildinfo`,
  },
};

// Must work at all levels: top, monorepo, one-package repo, subrepo
const TSCONFIG_OTHERS: ReadonlyRecord = {
  extends: './tsconfig.base.json',
  exclude: [...foldersWithoutConfigFiles, ...filesGeneratedByThirdParties],
  /* NoEmit cannot be set to true in a referenced project even though we never emit anything . rootDir, outDir and declarationDir need to be set otherwise Typescript will complain */
  compilerOptions: {
    tsBuildInfoFile: `.tsbuildinfo/${othersMark}.tsbuildinfo`,
    rootDir: '.',
    outDir: `${prodFolderName}/${othersFolderName}`,
    declarationDir: `${prodFolderName}/${othersFolderName}/${typesFolderName}`,
    //declarationMap: true
  },
};

const TSCONFIG_OTHERS_FOR_CONFIGS_PACKAGE = {
  ...TSCONFIG_OTHERS,
  // The others project of the configs package needs to import the source project for eslintConfig and prettierConfig
  references: [{ path: tsConfigSrcFilename }],
};

const GIT_IGNORE = [
  ...foldersGeneratedByThirdParties.map((folderName) => `/${folderName}/`),
  ...filesGeneratedByThirdParties.map((fileName) => `/${fileName}`),
].join('\n');

const VITEST_CONFIG_NO_CODE = `import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    projects: ['${packagesFolderName}/*'],
  },
})`;

const VITE_CONFIG_TRANSPILE = `/// <reference types="vitest" />
import { defineConfig } from 'vite';

export default defineConfig();`;

const VITE_CONFIG_BUNDLE = `/// <reference types="vitest" />
import { defineConfig } from 'vite';

export default defineConfig();`;

const GITHUB_WORKFLOWS_PUBLISH_SCRIPT = readFileSync('./assets/githubWorkflowsPublish.yml', 'utf8');
const GITHUB_WORKFLOWS_PAGES_SCRIPT = readFileSync('./assets/githubWorkflowsPages.yml', 'utf8');

const JUST_THE_DOCS_CONFIG = (packageName: string) => `remote_theme: mikearnaldi/just-the-docs
search_enabled: true
aux_links:
  "GitHub":
    - "//github.com/${owner}/${packageName}"`;

export type Type = ReadonlyRecord;

/** Config instance that implements what is necessary in all situations. */

const anyPackage = ({
  packageName,
  description,
  scripts,
  isConfigsPackage,
}: {
  readonly packageName: string;
  readonly description: string;
  readonly scripts: StringRecord;
  readonly isConfigsPackage: boolean;
}): Type => ({
  // Used by the format script
  [prettierConfigFilename]: PRETTIER_CONFIG,
  // Used by the format script
  [prettierIgnoreFilename]: PRETTIER_IGNORE,
  // Used by the tscheck script
  [tsConfigBaseFilename]: TSCONFIG_BASE,
  [packageJsonFilename]: {
    name: `${slashedScope}${packageName}`,
    // Needs to be present even at the top or root of a monorepo because there are some javascript config files
    type: 'module',
    description,
    author: 'Jérôme MARTIN',
    license: 'MIT',
    scripts: {
      // tests can be run at all levels, even at non project levels because there are vitest projects
      test: 'vitest run',
      tscheck: `tsc -b ${tsConfigFilename} --force`,
      lint: 'eslint .',
      'lint-and-analyze': 'eslint . --stats -f json > eslint-stats.json',
      'lint-rules': 'pnpx @eslint/config-inspector',
      format: 'prettier . --write',
      'generate-configs': `node ${binariesPath(isConfigsPackage)}/generate-configs.ts`,
      rmrf: `node ${binariesPath(isConfigsPackage)}/rmrf.ts`,
      mkdirp: `node ${binariesPath(isConfigsPackage)}/mkdirp.ts`,
      'clean-node-modules': 'pnpm rmrf node_modules',
      // Suppress package.json after because once suppressed the rmrf script no longer exists
      'clean-config-files': `pnpm rmrf ${tsConfigFilename} && pnpm rmrf ${packageJsonFilename}`,
      'reinstall-all-dependencies': 'pnpm i --force',
      ...scripts,
    },
    devDependencies:
      isConfigsPackage ? baseDevDependencies : (
        {
          ...baseDevDependencies,
          ...configsPeerDependencies,
          [`${slashedScope}${configsPackageName}`]: `git+ssh://${versionControlService}/${owner}/${configsPackageName}`,
        }
      ),
    ...(isConfigsPackage ? { peerDependencies: configsPeerDependencies } : {}),
  },
});

/**
 * Config instance taht implements what is necessary in a package that has no code (no esm
 * directory). This package is also a workspace.
 */
const noCodePackage = {
  // Used by the checks script
  [tsConfigFilename]: TSCONFIG_OTHERS,
  // Used by the checks script
  [eslintConfigFilename]: ESLINT_CONFIG_OTHERS,
  // Used by the test script
  [vitestConfigFilename]: VITEST_CONFIG_NO_CODE,
  [packageJsonFilename]: {
    scripts: {
      checks: 'pnpm tscheck && pnpm lint',
      'clean-all-node-modules': 'pnpm -r -include-workspace-root=true --reverse clean-node-modules',
      'clean-all-config-files': 'pnpm -r -include-workspace-root=true --reverse clean-config-files',
      'clean-all-prod': 'pnpm -r --parallel --aggregate-output clean-prod',
      // --if-present is necessary because it is possible that no package in the workspace has a build script
      'build-all': 'pnpm --if-present -r build',
      // --if-present is necessary because it is possible that no package in the workspace has an auto-update-imports script
      'auto-update-imports-for-all':
        'pnpm --if-present -r --parallel --aggregate-output auto-update-imports',
      // --if-present is necessary because it is possible that no package in the workspace has an update-imports script
      'update-imports-for-all': 'pnpm --if-present -r --parallel --aggregate-output update-imports',
      'generate-all-configs': 'pnpm -r --parallel --aggregate-output generate-configs',
      'tscheck-all': 'pnpm -r -include-workspace-root=true tscheck',
      'lint-all': 'pnpm -r -include-workspace-root=true lint',
      'checks-all': 'pnpm -r -include-workspace-root=true checks',
      'format-all': 'pnpm -r -include-workspace-root=true format',
    },

    /*pnpm: {
        patchedDependencies: {},
        overrides: {
          //'tsconfig-paths': '^4.0.0'
        },
      },*/
  },
};

/**
 * Config instance that implements what is necessary in a package that has code (an esm directory).
 * This package is also a workspace.
 */
/*
 * For a one-package repo, subRepoName and repoName are the same. For a subRepo, subRepoName is the
 * name of the subRepo and repo name the name of the repo that contains it.
 */
const codePackage = ({
  repoName,
  subRepoName,
  dependencies,
  devDependencies,
  peerDependencies,
  examples,
  buildMethod,
  environment,
  isPublished,
  hasDocGen,
  keywords,
  useEffectAsPeerDependency,
  useEffectPlatform,
  packagePrefix,
  isConfigsPackage,
  autogeneratedIndexTs,
  autogeneratedImports,
}: {
  readonly repoName: string;
  readonly subRepoName: string;
  readonly dependencies: StringRecord;
  readonly devDependencies: StringRecord;
  readonly peerDependencies: StringRecord;
  readonly examples: ReadonlyArray<string>;
  readonly buildMethod: string;
  readonly environment: string;
  readonly isPublished: boolean;
  readonly hasDocGen: boolean;
  readonly keywords: ReadonlyArray<string>;
  readonly useEffectAsPeerDependency: boolean;
  readonly useEffectPlatform: string;
  readonly packagePrefix: string;
  readonly isConfigsPackage: boolean;
  readonly autogeneratedIndexTs: string | undefined;
  readonly autogeneratedImports: ReadonlyRecord | undefined;
}): Type => {
  const [finalDependencies, finalPeerDependencies] =
    useEffectAsPeerDependency ?
      [dependencies, { ...peerDependencies, ...effectDependencies }]
    : [{ ...dependencies, ...effectDependencies }, peerDependencies];

  const buildConfig = (): Type => {
    if (buildMethod === 'None') return {};

    if (buildMethod === 'Transpile')
      return {
        [viteConfigFilename]: VITE_CONFIG_TRANSPILE,
        [packageJsonFilename]: {
          sideEffects: [],
          scripts: {
            compile:
              // tsc builds but also generate types. All my packages ship with the sideEffects-free key in package.json. And this is perfectly well understood by vite and rollup. So annotate-pure-calls is only necessary for published packages that might be used by clients who use old bundlers. As far as I am concerned, I do not need cjs code. Likewise, this is only necessary for published packages.
              `tsc -b ${tsConfigSrcFilename} --force`
              + (isPublished ?
                ` && babel ${prodFolderName}/${sourceFolderName} --out-dir ${prodFolderName}/${commonJsFolderName}`
                + '--plugins @babel/transform-export-namespace-from --plugins @babel/transform-modules-commonjs  --source-maps'
              : '')
              + ` && babel ${prodFolderName} --plugins annotate-pure-calls --out-dir ${prodFolderName} --source-maps`
              + ' && pnpm prodify-lib',
          },
        },
      };
    if (buildMethod === 'Bundle')
      return {
        [viteConfigFilename]: VITE_CONFIG_BUNDLE,
        [packageJsonFilename]: {
          module: `./${sourceFolderName}/main.js`,
          scripts: {
            bundle: 'bundle-files',
            compile: `pnpm bundle && pnpm prodify-bundle`,
          },
        },
      };

    // 'BundleWithDeps' , 'AppClient'
    throw new Error(
      `'${subRepoName}': disallowed value for 'buildMethod' parameter. Actual: '${buildMethod}'`,
    );
  };

  const visibilityConfig = ({
    repoName,
    isPublished,
    keywords,
  }: {
    readonly repoName: string;
    readonly isPublished: boolean;
    readonly keywords: ReadonlyArray<string>;
  }) =>
    isPublished ?
      {
        [packageJsonFilename]: {
          bugs: {
            url: `https://github.com/${owner}/${repoName}/issues`,
          },
          funding: [
            {
              type: 'ko-fi',
              url: 'https://ko-fi.com/parischap',
            },
          ],
          // Put specific keywords in first position so important keywords come out first
          keywords: [...keywords, 'effect', 'typescript', 'functional-programming'],
          scripts: {
            // Called by the publish github action defined in configInternalRepo.ts/
            'build-and-publish': 'pnpm build && pnpm checks && pnpm publish-to-npm',
            // npm publish ./dist --access=public does not work
            'publish-to-npm': `cd ${prodFolderName} && npm publish --access=public && cd ..`,
          },
        },
      }
    : {
        [packageJsonFilename]: {
          private: true,
        },
      };

  const docGenConfig = (hasDocGen: boolean) =>
    hasDocGen ?
      {
        [packageJsonFilename]: {
          scripts: {
            docgen: 'docgen',
          },
          devDependencies: docGenDependencies,
        },
        [tsConfigDocGenFilename]: tsconfigDocgen,
        [docgenConfigFilename]: docgenConfig,
      }
    : {};

  const platformConfig = ({
    subRepoName,
    useEffectPlatform,
  }: {
    readonly subRepoName: string;
    readonly useEffectPlatform: string;
  }) => {
    if (useEffectPlatform === 'No') return {};

    if (useEffectPlatform === 'AsDependency')
      return {
        [packageJsonFilename]: {
          dependencies: effectPlatformDependencies,
        },
      };

    if (useEffectPlatform === 'AsPeerDependency')
      return {
        [packageJsonFilename]: {
          peerDependencies: effectPlatformDependencies,
        },
      };

    throw new Error(
      `'${subRepoName}': disallowed value for 'useEffectPlatform' parameter. Actual: '${useEffectPlatform}'`,
    );
  };

  const environmentConfig = ({
    subRepoName,
    environment,
    isConfigsPackage,
  }: {
    readonly subRepoName: string;
    readonly environment: string;
    readonly isConfigsPackage: boolean;
  }) => {
    const base = {
      // Used by the tscheck script
      [tsConfigFilename]: tsConfig,
      // Used by the tsConfig file
      [tsConfigOthersFilename]: tsConfigOthers({ isConfigsPackage }),
      // Used by the tsConfig file
      [tsConfigExamplesFilename]: tsConfigExamples,
      // Used by the tsConfig file
      [tsConfigTestsFilename]: tsConfigTests,
    };

    if (environment === 'Browser')
      return {
        ...base,
        // Used by the checks script
        [tsConfigSrcFilename]: tsConfigEsmBrowser,
        // Used by the checks script
        // We don't use any dom specifities because it must run on the server. It's all hidden away in preact
        [eslintConfigFilename]: eslintConfigSrcBrowser,
      };

    if (environment === 'Node')
      return {
        ...base,
        // Used by the checks script
        [tsConfigSrcFilename]: tsConfigEsmNode,
        // Used by the checks script
        [eslintConfigFilename]: eslintConfigSrcNode,
      };

    if (environment === 'Plain')
      return {
        ...base,
        // Used by the checks script
        [tsConfigSrcFilename]: tsConfigEsmPlain,
        // Used by the checks script
        [eslintConfigFilename]: eslintConfigSrcPlain,
      };

    throw new Error(
      `'${subRepoName}': disallowed value for 'environment' parameter. Actual: '${environment}'`,
    );
  };

  return deepMerge(
    {
      // Used by the circular script
      [madgeConfigFilename]: madgeConfig,
      // Used by the test script
      [vitestConfigFilename]: projectVitestConfig(subRepoName),
      ...(packagePrefix === '' ? {} : { [indexTsFilename]: autogeneratedIndexTs }),
      [packageJsonFilename]: {
        module: `./${sourceFolderName}/index.js`,
        exports: autogeneratedImports,
        ...(Object.keys(finalDependencies).length === 0 ? {} : { dependencies: finalDependencies }),
        ...(Object.keys(finalPeerDependencies).length === 0 ?
          {}
        : { peerDependencies: finalPeerDependencies }),
        devDependencies: {
          /* Include test-utils for tests except if the package is:
          - test-utils because it does not need to inclue itself
          - configs: to avoid circular dependencies
          */
          ...projectDevDependencies,
          ...devDependencies,
        },
        scripts: {
          circular: `madge --extensions ts --circular --no-color --no-spinner ${sourceFolderName}`,
          'clean-prod': `pnpm rmrf ${prodFolderName} && pnpm mkdirp ${prodFolderName}`,
          checks: 'pnpm circular && pnpm tscheck && pnpm lint && pnpm test',
          build: 'pnpm clean-prod && pnpm compile && cd ${prodFolderName} && pnpm i && cd ..',
          examples: examples
            .map((exampleName) => `${tsExecuter} ${examplesFolderName}/${exampleName}`)
            .join('&&'),
          ...(packagePrefix === '' ?
            {}
          : {
              'update-imports': `node ${binariesPath(isConfigsPackage)}/update-imports.ts run ${packagePrefix}`,
              'auto-update-imports': `node ${binariesPath(isConfigsPackage)}/update-imports.ts watch ${packagePrefix}`,
            }),
        },
        // Must be present even for private packages as it can be used for other purposes
        repository: {
          type: 'git',
          // Use git+https protocol as specified in npm documentation
          url: `git+https://${versionControlService}/${owner}/${repoName}.git`,
          ...(subRepoName === repoName ?
            {}
          : {
              directory: `${packagesFolderName}/${subRepoName}`,
            }),
        },
        // Must be present even for private packages as it can be used for instance by docgen
        homepage:
          // Use https protocol as specified in npm documentation
          `https://${versionControlService}/${owner}/${repoName}`
          + (subRepoName === repoName ? '' : `/tree/master/${packagesFolderName}/${subRepoName}`),
      },
    },
    buildConfig({ subRepoName, buildMethod, isPublished }),
    visibilityConfig({ repoName, isPublished, keywords }),
    docGenConfig(hasDocGen),
    platformConfig({ subRepoName, useEffectPlatform }),
    environmentConfig({ subRepoName, environment, isConfigsPackage }),
  );
};

/** Config instance that implements what is necessary at the root of a git (and github) repo */
const repo = ({
  docGenParameters,
  isPublished,
}: {
  readonly docGenParameters?: { readonly packageName: string; readonly description: string };
  readonly isPublished: boolean;
}): Type => ({
  ...(isPublished ?
    /* Github actions need to be at the root of the github repo. This action calls a script `build-and-publish` but changes the working directory to the published package directory before calling them. So this script must be in configInternalProject.ts.
     */
    {
      [`${githubFolderName}/${workflowsFolderName}/${githubWorkflowsPublishFilename}`]:
        GITHUB_WORKFLOWS_PUBLISH_SCRIPT,
    }
  : {}),
  ...(docGenParameters !== undefined ?
    {
      /* Github actions need to be at the root of the github repo. This action calls a script `prepare-docs'`  */
      [`${githubFolderName}/${workflowsFolderName}/${githubWorkflowsPagesFilename}`]:
        GITHUB_WORKFLOWS_PAGES_SCRIPT,
      // Used by the github pages.yml action
      [`${docsFolderName}/${docsIndexMdFilename}`]: docGenParameters.description,
      // Used by the github pages.yml action
      [`${docsFolderName}/${docsConfigYmlFilename}`]: JUST_THE_DOCS_CONFIG(
        docGenParameters.packageName,
      ),
    }
  : {}),
  [gitIgnoreFilename]: GIT_IGNORE,
  [packageJsonFilename]: {
    packageManager,
    ...(docGenParameters !== undefined ?
      {
        scripts: {
          // --if-present is necessary because it is possible that no package in the workspace has a docgen script
          'prepare-docs':
            'pnpm -r --if-present -include-workspace-root=true --parallel --aggregate-output docgen && compile-docs',
        },
      }
    : {}),

    /*pnpm: {
      patchedDependencies: {},
      overrides: {
        //'tsconfig-paths': '^4.0.0'
      },
    },*/
  },
});
