/**
 * Module that serves as a base for all Package types (see README.md and Package.ts). It can be used
 * for all operations that don't require reading the project configuration file of the Package
 */
/* This module must not import any external dependency. It must be runnable without a package.json because it is used by the generate-config-files.ts bin */

import { join } from 'path';
import {
  configFilename,
  readMeFilename,
  viteTimeStampFilenamePattern,
} from '../../shared-utils/constants.js';
import { Data, objectFromDataAndProto, Proto, Record } from '../../shared-utils/types.js';
import { readJsonFile, toMiniGlobRegExp } from '../../shared-utils/utils.js';
import * as ConfigFiles from '../ConfigFiles.js';

/**
 * Module tag
 *
 * @category Module markers
 */
const _moduleTag = '@parischap/configs/internal/bin-utils/Package/Base/';
const _TypeId: unique symbol = Symbol.for(_moduleTag) as _TypeId;
export type _TypeId = typeof _TypeId;

/**
 * Symbol used for the `externalConfigurationFiles` property
 *
 * @category Models
 */
export const externalConfigurationFilesSymbol: unique symbol = Symbol.for(
  _moduleTag + 'externalConfigurationFiles/',
);

/**
 * Symbol used for the `toPackageFiles` property
 *
 * @category Models
 */
export const toPackageFilesSymbol: unique symbol = Symbol.for(_moduleTag + 'toPackageFiles/');

/**
 * Symbol used for the `isSourcePackage` property
 *
 * @category Models
 */
export const isSourcePackageSymbol: unique symbol = Symbol.for(_moduleTag + 'isSourcePackage/');

/**
 * Type of a Base
 *
 * @category Models
 */
export interface Type {
  /** Tag of the package */
  readonly tag: 'Top' | 'MonoRepo' | 'OnePackageRepo' | 'SubPackage';
  /** Name of the package */
  readonly name: string;
  /** Name of the parent MonoRepo of `self` if self is a SubPackage. Equal to `name` otherwise */
  readonly parentName: string;
  /** Relative path to the package root */
  readonly path: string;
  /** Flag that indicates if `self` is the configs package */
  readonly isConfigsPackage: boolean;
  /**
   * RegExp that matches configuration files that are allowed to be in the package although not
   * generated by the configs package
   */
  readonly [externalConfigurationFilesSymbol]: RegExp;
  /** Generates the PackageFiles for `this` */
  readonly [toPackageFilesSymbol]: (exportsFilesOnly: boolean) => Promise<ConfigFiles.Type>;

  /** @internal */
  readonly [_TypeId]: _TypeId;
}

/**
 * Type guard
 *
 * @category Guards
 */
export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

/** _prototype */
export const proto: Proto<Type> = {
  [_TypeId]: _TypeId,
  [externalConfigurationFilesSymbol]: toMiniGlobRegExp([
    readMeFilename,
    configFilename,
    viteTimeStampFilenamePattern,
  ]),
  [toPackageFilesSymbol](this: Type, exportsFilesOnly: boolean): Promise<ConfigFiles.Type> {
    return Promise.resolve(exportsFilesOnly ? ConfigFiles.empty : ConfigFiles.anyPackage(this));
  },
};

/**
 * Constructor
 *
 * @category Constructors
 */
export const make = (data: Data<Type>): Type => objectFromDataAndProto(proto, data);

/**
 * Reads the configuration file of `self`
 *
 * @category Destructors
 */
export const readConfigFile = async (self: Data<Type>): Promise<Record> =>
  readJsonFile(join(self.path, configFilename));
