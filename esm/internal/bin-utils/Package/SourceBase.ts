/** Module that serves as a base for all source Package types (see README.md and Package.ts) */
/* This module must not import any external dependency. It must be runnable without a package.json because it is used by the generate-config-files.ts bin */

import {
  Data,
  objectFromDataAndProto,
  Proto,
  StringArray,
  StringRecord,
} from '../../shared-utils/types.js';
import * as ConfigFiles from '../ConfigFiles.js';
import * as JsonConfigFileDecoder from '../JsonConfigFile/Decoder.js';
import * as PackageBase from './Base.js';

/**
 * Module tag
 *
 * @category Module markers
 */
const _moduleTag = '@parischap/configs/internal/bin-utils/Package/SourceBase/';
const _TypeId: unique symbol = Symbol.for(_moduleTag) as _TypeId;
type _TypeId = typeof _TypeId;

/**
 * Type of a SourceBase
 *
 * @category Models
 */
export interface Type extends PackageBase.Type {
  /** Description of the package */
  readonly description: string;
  /** `dependencies` used by the package except Effect and Effect platform (default value: {}) */
  readonly dependencies: Readonly<StringRecord>;
  /** `devDependencies` used by the package (default value: {}) */
  readonly devDependencies: Readonly<StringRecord>;
  /** `peerDependencies` used by the package except Effect and Effect platform (default value: {}) */
  readonly peerDependencies: Readonly<StringRecord>;
  /**
   * array of available examples to add as `examples` script under the package.json scripts field
   * (default value: [])
   */
  readonly examples: Readonly<StringArray>;
  /** Scripts to add to package.json (default value: {}) */
  readonly scripts: Readonly<StringRecord>;
  /**
   * One of `Browser`, `Node` or `Plain`. Note that, in our case, we do not use the DOM specific
   * variables in the `Browser` environment because the browser code must be runnable on the server
   * for server-side rendering. All the DOM manipulation is hidden away in Preact
   */
  readonly environment: string;
  /**
   * One of:
   *
   * - transpile: all modules in the `esm` directory, whether under the `internal` and `bin`
   *   subdirectories or not, are simply transpiled to JavaScript. Nothing gets bundled. If the
   *   package uses any dependencies, they must be installed in the prod package as well. This is
   *   usually a good choice for libraries.
   * - light-bundling: all modules in the `esm` directory except those under the `internal`
   *   subdirectory are transpiled to JavaScript and bundled with the modules under the `internal`
   *   subdirectory. If the package uses any dependencies, they must be installed in the prod
   *   package as well. This is usually a good choice for code that does not need to ship as a
   *   standalone package. Not bundling external dependencies allows to keep the package small,
   *   reduce build time and start time as all the packages need not be loaded at once. This is
   *   usually a good choice for a web server.
   * - deep-bundling: all modules in the `esm` directory except those under the `internal`
   *   subdirectory are transpiled to JavaScript and bundled with the modules under the `internal`
   *   subdirectory and all installed packages. If the package uses any dependencies, they will not
   *   be installed in the prod package. This is usually a good choice for a standalone command
   */
  readonly buildMethod: string;
  /** Boolean that indicates if the package will be published to NPM */
  readonly isPublished: boolean;
  /**
   * Boolean that indicates if package documentation must be generated by docgen. Note that no
   * documentation will be produced for modules under the `internal` directory
   */
  readonly hasDocGen: boolean;
  /**
   * Array of keywords to add to the package. Will be ignored if the package is private (default:
   * [])
   */
  readonly keywords: Readonly<StringArray>;
  /**
   * Effect is by default added as dependency to all packages. If this flag is set to true, it is
   * added as a peerDependency
   */
  readonly useEffectAsPeerDependency: boolean;
  /** If true, Effect platform and all its peerDependencies are added as dependency to the package */
  readonly useEffectPlatform: string;
  /**
   * String that will be prefix when automatically generating namespace imports for the package.
   * Namespace imports will be automatically generated even if packagePrefix is an empty string. To
   * deactivate it, omit the field.
   */
  readonly packagePrefix: string | undefined;

  /** @internal */
  readonly [_TypeId]: _TypeId;
}

/**
 * Type guard
 *
 * @category Guards
 */
export const has = (u: unknown): u is Type => typeof u === 'object' && u !== null && _TypeId in u;

/** _prototype */
const parentProto = PackageBase.proto;
export const proto: Proto<Type> = objectFromDataAndProto(parentProto, {
  [_TypeId]: _TypeId,
  async [PackageBase.toPackageFilesSymbol](
    this: Type,
    exportsFilesOnly: boolean,
  ): Promise<ConfigFiles.Type> {
    return Promise.resolve(
      ConfigFiles.merge(
        await parentProto[PackageBase.toPackageFilesSymbol].call(this, exportsFilesOnly),
        await (exportsFilesOnly ?
          ConfigFiles.sourcePackageExports(this)
        : ConfigFiles.sourcePackage(this)),
      ),
    );
  },
} as const);

const _make = (data: Data<Type>): Type => objectFromDataAndProto(proto, data);

/**
 * Constructor
 *
 * @category Constructors
 */
export const fromPackageBase = async ({
  packageBase,
}: {
  readonly packageBase: PackageBase.Type;
}): Promise<Type> =>
  _make({
    ...packageBase,
    ...JsonConfigFileDecoder.sourcePackage({
      configurationFileObject: await PackageBase.readProjectConfigFile(packageBase),
      packageName: packageBase.name,
    }),
  });
