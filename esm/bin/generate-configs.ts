/**
 * This binary generates the configuration files, including the `index.ts` file for those packages that need autogeneration of that file.
 * 
 * If this binary is called at the level of the configs repo, it generates the configuration files at all levels (top, repos, subrepos). If it is called at any other level, it only generates the configuration files at that level.
 * 
 * Each package, except the top package, must contain a `project.config.json` file that contains the parameters of that package. The parameters of the top package are stored in this binary, so that the top package does not need to be saved on github. Based on the parameters, this binary creates a configuration object whose keys are the names of the files to create. If it's a `json` file, the associated value is converted from an object to a json
 * string with JSON.stringfy. Otherwise, the associated value must be a string and it is written as is.
 * 
 * This binary also checks that there are no unexpected config files present in the package, i.e config
 * files which are not created by this bin (there are a few exceptions: the `project.config.js` file
 * itself, the `README.md` file... see `patternsToIgnore` below).
 * 
 */
/* This module must not import any external dependency. It must be runnable without a package.json. It must only use Typescript syntax understandable by Node with the --experimental-transform-types flag */
import { mkdir, readFile, rm } from 'node:fs/promises';
import { dirname, extname, join, resolve, sep } from 'node:path';
import { generateImports } from '../internal/bin-utils/update-imports.js';
import configMonoRepo from '../internal/configs-generation/configMonoRepo.js';
import configOnePackageRepo from '../internal/configs-generation/configOnePackageRepo.js';
import configSubRepo from '../internal/configs-generation/configSubRepo.js';
import configTop from '../internal/configs-generation/configTop.js';
import {
  configFilename,
  configsPackageName,
  foldersGeneratedByThirdParties,
  indexTsFilename,
  packageJsonFilename,
  packagesFolderName,
  pnpmLockFilename,
  prodFolderName,
  readMeFilename,
  sourceFolderName,
  viteTimeStampFilenamePattern
} from '../internal/shared-utils/constants.js';
import {
  isReadonlyStringArray,
  isReadonlyStringRecord,
  isRecord,
  PackageWithSourceConfigParameters,
  Record,
  type Config,
} from '../internal/shared-utils/types.js';
import {
  deepMerge,
  fromOSPathToPosixPath,
  fromPosixPathToOSPath,
  prettyStringify,
  readFiles,
  readFilesRecursively,
  readFolders,
  regExpEscape,
  writeAutogeneratedFile
} from '../internal/shared-utils/utils.js';

const fromPatternsToRegExp = (patterns: ReadonlyArray<string>): RegExp =>
  new RegExp(
    '^'
      + patterns.map((pattern) => regExpEscape(pattern).replace(/\*/g, '[^\\/]*')).join('|')
      + '$',
  );

// List of configuration files for which an error must not be reported if they are present in the top package and not overridden by project.config.js
const patternsToIgnoreInTopPackage = [readMeFilename, pnpmLockFilename];
const patternsToIgnoreInTopPackageRegExp = fromPatternsToRegExp(patternsToIgnoreInTopPackage);

// List of configuration files for which an error must not be reported if they are present in the package and not overridden by project.config.js
const patternsToIgnoreInOtherPackages = [readMeFilename, configFilename, viteTimeStampFilenamePattern];
const patternsToIgnoreInOtherPackagesRegExp = fromPatternsToRegExp(patternsToIgnoreInOtherPackages);

const readConfigFile = async ({path, tag}:{readonly path: string, readonly tag: string}):Promise<Record> => {
  console.log(`${tag}reading configuration file`)

  const configFile = await readFile(join(path, configFilename), 'utf8');

  const configObject: unknown = JSON.parse(configFile);

  if (!isRecord(configObject))
    throw new Error(
      `'${configFilename}' must contain the json representation of a non-null object`,
    );
    return configObject
}

const decodeMonoRepoConfigObject = ({configObject, repoName, repoTag}:{readonly configObject: Record, readonly repoName: string, readonly repoTag: string}):Config=>{
  console.log(`${repoTag}decoding monorepo configuration file`)
  const description = configObject['description'];
    if (typeof description !== 'string')
      throw new Error(
        `Parameter 'description' of '${configFilename}' should be of type string'`,
      );

    const extraKeys = Object.keys(configObject).filter(
      (key) => key!== 'description',
    );
    if (extraKeys.length !== 0)
      throw new Error(
        `'${configFilename}' contains unexpected parameters for monorepo config: '${extraKeys.join("', '")}'`,
      );

    return configMonoRepo({ repoName, description });
}

const getConfigParamsForPackageWithSource = ({configObject, configName}:{readonly configObject: Record, readonly configName:string}):PackageWithSourceConfigParameters=>{
  const description = configObject['description'];
  if (typeof description !== 'string')
    throw new Error(
      `Parameter 'description' of '${configFilename}' should be of type string'`,
    );

  const dependencies = configObject['dependencies'] ?? {};
  if (!isReadonlyStringRecord(dependencies))
    throw new Error(
      `Parameter 'dependencies' of '${configFilename}' should be of type ReadonlyStringRecord'`,
    );

  const devDependencies = configObject['devDependencies'] ?? {};
  if (!isReadonlyStringRecord(devDependencies))
    throw new Error(
      `Parameter 'devDependencies' of '${configFilename}' should be of type ReadonlyStringRecord'`,
    );

  const peerDependencies = configObject['peerDependencies'] ?? {};
  if (!isReadonlyStringRecord(peerDependencies))
    throw new Error(
      `Parameter 'peerDependencies' of '${configFilename}' should be of type ReadonlyStringRecord'`,
    );

  const examples = configObject['examples'] ?? [];
  if (!isReadonlyStringArray(examples))
    throw new Error(
      `Parameter 'examples' of '${configFilename}' should be of type ReadonlyStringArray'`,
    );

  const scripts = configObject['scripts'] ?? {};
  if (!isReadonlyStringRecord(scripts))
    throw new Error(
      `Parameter 'scripts' of '${configFilename}' should be of type ReadonlyStringRecord'`,
    );

  const environment = configObject['environment'];
  if (typeof environment !== 'string')
    throw new Error(
      `Parameter 'environment' of '${configFilename}' should be of type string'`,
    );

  const buildMethod = configObject['buildMethod'];
  if (typeof buildMethod !== 'string')
    throw new Error(
      `Parameter 'buildMethod' of '${configFilename}' should be of type string'`,
    );

  const isPublished = configObject['isPublished'];
  if (typeof isPublished !== 'boolean')
    throw new Error(
      `Parameter 'isPublished' of '${configFilename}' should be of type boolean'`,
    );

  const hasDocGen = configObject['hasDocGen'];
  if (typeof hasDocGen !== 'boolean')
    throw new Error(
      `Parameter 'hasDocGen' of '${configFilename}' should be of type boolean'`,
    );

  const keywords = configObject['keywords'] ?? [];
  if (!isReadonlyStringArray(keywords))
    throw new Error(
      `Parameter 'keywords' of '${configFilename}' should be of type ReadonlyStringArray'`,
    );

  const useEffectAsPeerDependency = configObject['useEffectAsPeerDependency'];
  if (typeof useEffectAsPeerDependency !== 'boolean')
    throw new Error(
      `Parameter 'useEffectAsPeerDependency' of '${configFilename}' should be of type boolean'`,
    );

  const useEffectPlatform = configObject['useEffectPlatform'] ?? 'No';
  if (typeof useEffectPlatform !== 'string')
    throw new Error(
      `Parameter 'useEffectPlatform' of '${configFilename}' should be of type string'`,
    );

  const packagePrefix = configObject['packagePrefix'];
  if (typeof packagePrefix !== 'string')
    throw new Error(
      `Parameter 'packagePrefix' of '${configFilename}' should be of type string'`,
    );

  const extraKeys = Object.keys(configObject).filter(
    (key) =>
      ![
        'configName',
        'description',
        'dependencies',
        'devDependencies',
        'peerDependencies',
        'examples',
        'scripts',
        'environment',
        'buildMethod',
        'isPublished',
        'hasDocGen',
        'keywords',
        'useEffectAsPeerDependency',
        'useEffectPlatform',
        'packagePrefix',
      ].includes(key),
  );
  if (extraKeys.length !== 0)
    throw new Error(
      `'${configFilename}' contains unexpected parameters for config '${configName}': '${extraKeys.join("', '")}'`,
    );
  return {
        description,
        dependencies,
        devDependencies,
        peerDependencies,
        examples,
        scripts,
        environment,
        buildMethod,
        isPublished,
        hasDocGen,
        keywords,
        useEffectAsPeerDependency,
        useEffectPlatform,
        packagePrefix,
      }

}

const configImports = async ({packagePath, packagePrefix,isConfigsPackage, tag}:{readonly packagePath: string, readonly packagePrefix: string, readonly isConfigsPackage:boolean, readonly tag: string}) => {
  console.log(`${tag}adding autogenerated imports configuration`)
  const [indexTsContents, packageJsonExports] = await generateImports({sourcePath: join(packagePath, sourceFolderName),packagePrefix,keepFileExtensions:isConfigsPackage})
  return {
    [indexTsFilename]: indexTsContents,
    [packageJsonFilename]: {
      exports: packageJsonExports,
    }
  }

}

const decodeOnePackageRepoConfigObject = async ({configObject, repoPath, repoName, isConfigsPackage, repoTag}:{readonly configObject: Record, readonly repoPath:string, readonly repoName: string, readonly isConfigsPackage: boolean, readonly repoTag: string}):Promise<Config>=>{
  console.log(`${repoTag}decoding one-package repo configuration file`)
  const params = getConfigParamsForPackageWithSource({configObject,configName:'one-package repo'})
  const importsConfigs = await configImports({packagePath: repoPath,packagePrefix:params.packagePrefix, isConfigsPackage,tag: repoTag})
 return deepMerge(configOnePackageRepo({ repoName,isConfigsPackage, ...params }),importsConfigs);
}

const decodeSubRepoConfigObject = async ({configObject, subRepoPath, subRepoName, repoName, subRepoTag}:{readonly configObject: Record, readonly subRepoPath:string, readonly subRepoName: string, readonly repoName: string,readonly subRepoTag: string}):Promise<Config>=>{
  console.log(`${subRepoTag}decoding sub-repo configuration file`)
  const params = getConfigParamsForPackageWithSource({configObject,configName:'sub-repo'})
  const importsConfigs = await configImports({packagePath: subRepoPath,packagePrefix:params.packagePrefix, isConfigsPackage:false,tag: subRepoTag})
 return deepMerge(configSubRepo({repoName, subRepoName, ...params }),importsConfigs);
}

const checkUselessFiles = async ({
  config,
  packagePath,
  isTopPackage,
  tag,
}: {
  readonly config:Config,
  readonly packagePath: string;
  readonly isTopPackage: boolean;
  readonly tag:string
}):Promise<void> => {
  console.log(`${tag}determining potential useless files`);

  // In project.config.ts, paths are posix-Style. Let's convert them to OS style
  const filesToCreate = Object.keys(config).map(fromPosixPathToOSPath);

  const configFiles = 
    await readFilesRecursively({path: packagePath,foldersToExclude:foldersGeneratedByThirdParties, dontFailOnInexistentPath:false})

  const unexpectedConfigFiles = [...configFiles
    .filter(
      ({ relativePath }) =>
        !filesToCreate.includes(relativePath)
        && !(isTopPackage ? patternsToIgnoreInTopPackageRegExp : patternsToIgnoreInOtherPackagesRegExp).test(relativePath)
    )
    .map(({ relativePath }) => relativePath), ...(await readFiles({path:join(packagePath, packagesFolderName), dontFailOnInexistentPath:true})).map((name) => `${packagesFolderName}/${name}`)];

  if (unexpectedConfigFiles.length > 0)
    throw new Error(
      'Following unexpected files where found in the package:\n'
        + unexpectedConfigFiles.join(',\n'),
    );
};

const saveConfig = async ({
  config,
  packagePath,
  tag,
}: {
  readonly config:Config,
  readonly packagePath: string;
  readonly tag:string
}):Promise<void> => {
   
  console.log(`${tag}writing configuration files`);
  for (const [filename, fileContent] of Object.entries(config)) {
    const contentToWriteFunc =
      extname(filename) === '.json' ? () => prettyStringify(fileContent)
      : typeof fileContent === 'string' ? () => fileContent
      : () => {
          throw new Error(
            `Entry '${filename}' in '${configFilename}' must have value of type string`,
          );
        };

    const targetFilename = join(packagePath, filename);
    // Create directory in case it does not exist
    /* eslint-disable-next-line functional/no-expression-statements*/
    await mkdir(dirname(targetFilename), { recursive: true });

    /* eslint-disable-next-line functional/no-expression-statements*/
    await writeAutogeneratedFile({path:targetFilename, newContents:contentToWriteFunc()});
  }
};

const splitPath = fromOSPathToPosixPath(resolve()).split('/')
const firstPackagesIndex = splitPath.findIndex((split)=>split===packagesFolderName)
if (firstPackagesIndex <= 0)
  throw new Error('Could not find root of monorepo')
const topPath = splitPath.slice(0,firstPackagesIndex).join(sep)
const topRepoName = splitPath[firstPackagesIndex-1] as string;

console.log(`Top repo '${topRepoName}' identified at: '${topPath}'\n`);

const topPackagesPath = join(topPath, packagesFolderName);
const repoNames =
  await readFolders({ path: topPackagesPath, dontFailOnInexistentPath: false });

const repoTree = (await Promise.all(repoNames.map(async (repoName)=>
{
  const repoTag = `  '${repoName}': `
  const repoPath = join(topPackagesPath, repoName)
  const subPackagesPath = join(repoPath, packagesFolderName)
  const subRepos = await readFolders({
    path: subPackagesPath,
    dontFailOnInexistentPath: true,
  });

  const isConfigsPackage = repoName === configsPackageName
  const isMonoRepo = subRepos.length === 0;
  
  const configObject = await readConfigFile({path:repoPath, tag:repoTag})

  const config = isMonoRepo ? decodeMonoRepoConfigObject({configObject, repoName,repoTag}) : await decodeOnePackageRepoConfigObject({configObject,repoPath, repoName, repoTag, isConfigsPackage})
  
  await checkUselessFiles({config,packagePath:repoPath,isTopPackage:false,tag:repoTag});
  await saveConfig({config,packagePath:repoPath,tag:repoTag});

  if (!isMonoRepo) {
      /* Remove dist directories of one-package repos because the packages will need rebuilding and these directories might contain conflicting versions of imported packages */
      console.log(`${repoTag}removing dist directory`);
      /* eslint-disable-next-line functional/no-expression-statements*/
      await rm(join(repoPath, prodFolderName), { force: true, recursive: true });
  }
  
  /* eslint-disable-next-line functional/no-expression-statements*/
  await Promise.all(
    subRepos.map(async (subRepoName) => {
      const subRepoTag = `    '${subRepoName}': `
      const subRepoPath = join(subPackagesPath, subRepoName)

      const configObject = await readConfigFile({path:subRepoPath, tag:subRepoTag})

      const config = await decodeSubRepoConfigObject({configObject,subRepoPath, subRepoName, repoName, subRepoTag})
  
  await checkUselessFiles({config,packagePath:subRepoPath,isTopPackage:false,tag:subRepoTag});
  await saveConfig({config,packagePath:subRepoPath,tag:subRepoTag});

      /* Remove dist directories of subrepos because the packages will need rebuilding and these directories might contain conflicting versions of imported packages */
      console.log(`${subRepoTag}removing dist directory`);
      /* eslint-disable-next-line functional/no-expression-statements*/
      await rm(join(subRepoPath, prodFolderName), { force: true, recursive: true });
    }),
  );

  return [`${packagesFolderName}/repoName`, ...subRepos.map((subRepoName)=>`${packagesFolderName}/repoName/${packagesFolderName}/${subRepoName}`)]

}
))).flat()

const a = configTop({ description:'Top repo of my developments' })
console.log('SUCCESS');
