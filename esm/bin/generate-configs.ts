/**
 * This binary generates the configuration files, including the `index.ts` file for those packages
 * that need autogeneration of that file.
 *
 * If this binary is called at the level of the configs repo, it generates the configuration files
 * at all levels (top, repos, subrepos). If it is called at any other level, it only generates the
 * configuration files at that level.
 *
 * Each package, except the top package, must contain a `project.config.json` file that contains the
 * parameters of that package. The parameters of the top package are stored in this binary, so that
 * the top package does not need to be saved on github. Based on the parameters, this binary creates
 * a configuration object whose keys are the names of the files to create. If it's a `json` file,
 * the associated value is converted from an object to a json string with JSON.stringfy. Otherwise,
 * the associated value must be a string and it is written as is.
 *
 * This binary also checks that there are no unexpected config files present in the package, i.e
 * config files which are not created by this bin (there are a few exceptions: the
 * `project.config.js` file itself, the `README.md` file... see `patternsToIgnore` below).
 */
/* This module must not import any external dependency. It must be runnable without a package.json. It must only use Typescript syntax understandable by Node with the --experimental-transform-types flag */
import { mkdir, readFile, rm } from 'node:fs/promises';
import { dirname, extname, join, resolve, sep } from 'node:path';
import { generateImports } from '../internal/bin-utils/generate-imports.js';
import configMonoRepo from '../internal/configs-generation/configMonoRepo.js';
import configOnePackageRepo from '../internal/configs-generation/configOnePackageRepo.js';
import configSubRepo from '../internal/configs-generation/configSubRepo.js';
import configTop from '../internal/configs-generation/configTop.js';
import {
  configFilename,
  configsPackageName,
  foldersGeneratedByThirdParties,
  packagesFolderName,
  pnpmLockFilename,
  prodFolderName,
  readMeFilename,
  sourceFolderName,
  tsBuildInfoFolderName,
  viteTimeStampFilenamePattern,
} from '../internal/shared-utils/constants.js';
import {
  isRecord,
  isStringArray,
  isStringRecord,
  PackageWithSourceConfigParameters,
  Record,
  StringArray,
  StringRecord,
  type Config,
} from '../internal/shared-utils/types.js';
import {
  fromPosixPathToOSPath,
  prettyStringify,
  readFiles,
  readFilesRecursively,
  readFolders,
  regExpEscape,
  writeAutogeneratedFile,
} from '../internal/shared-utils/utils.js';

const fromPatternsToRegExp = (patterns: ReadonlyArray<string>): RegExp =>
  new RegExp(
    '^'
      + patterns.map((pattern) => regExpEscape(pattern).replace(/\*/g, '[^\\/]*')).join('|')
      + '$',
  );

// List of configuration files for which an error must not be reported if they are present in the top package and not overridden by project.config.js
const patternsToIgnoreInTopPackage = [readMeFilename, pnpmLockFilename];
const patternsToIgnoreInTopPackageRegExp = fromPatternsToRegExp(patternsToIgnoreInTopPackage);

// List of configuration files for which an error must not be reported if they are present in the package and not overridden by project.config.js
const patternsToIgnoreInOtherPackages = [
  readMeFilename,
  configFilename,
  viteTimeStampFilenamePattern,
];
const patternsToIgnoreInOtherPackagesRegExp = fromPatternsToRegExp(patternsToIgnoreInOtherPackages);

const readConfigFile = async ({
  path,
  tag,
}: {
  readonly path: string;
  readonly tag: string;
}): Promise<Record> => {
  console.log(`${tag}reading configuration file`);

  const configFile = await readFile(join(path, configFilename), 'utf8');

  const configObject: unknown = JSON.parse(configFile);

  if (!isRecord(configObject))
    throw new Error(
      `${tag}'${configFilename}' must contain the json representation of a non-null object`,
    );
  return configObject;
};

type TypeFromTypeName<T> =
  [T] extends ['string'] ? string
  : [T] extends ['boolean'] ? boolean
  : [T] extends ['record'] ? StringRecord
  : StringArray;

const extractParam = <
  N extends string,
  E extends 'string' | 'boolean' | 'record' | 'array',
  R extends Record,
>({
  configObject,
  parameterName,
  expectedType,
  optionalValue,
  extractedParams,
  tag,
}: {
  readonly configObject: Record;
  readonly parameterName: N;
  readonly expectedType: E;
  readonly optionalValue?: TypeFromTypeName<E>;
  readonly extractedParams: R;
  readonly tag: string;
}): R & { [k in N]: TypeFromTypeName<E> } => {
  const value = configObject[parameterName];
  if (optionalValue !== undefined && value === undefined)
    return { ...extractedParams, [parameterName]: optionalValue } as never;
  if (
    (expectedType === 'string' && typeof value !== 'string')
    || (expectedType === 'boolean' && typeof value !== 'boolean')
    || (expectedType === 'record' && !isStringRecord(value))
    || (expectedType === 'array' && !isStringArray(value))
  )
    throw new Error(
      `${tag}parameter '${parameterName}' of '${configFilename}' should be of type '${expectedType}'. Actual: ${typeof value}`,
    );
  return { ...extractedParams, [parameterName]: value } as never;
};

const decodeMonoRepoConfigObject = ({
  configObject,
  repoName,
  repoTag,
}: {
  readonly configObject: Record;
  readonly repoName: string;
  readonly repoTag: string;
}): Config => {
  console.log(`${repoTag}decoding monorepo configuration file`);
  const withDescription = extractParam({
    configObject,
    parameterName: 'description',
    expectedType: 'string',
    extractedParams: {},
    tag: repoTag,
  });

  const extractedKeys = Object.keys(withDescription);
  const extraKeys = Object.keys(configObject).filter((key) => !extractedKeys.includes(key));
  if (extraKeys.length !== 0)
    throw new Error(
      `${repoTag}'${configFilename}' contains unexpected parameters for monorepo config: '${extraKeys.join("', '")}'`,
    );

  return configMonoRepo({ repoName, ...withDescription });
};

const getConfigParamsForPackageWithSource = async ({
  configObject,
  packagePath,
  isConfigsPackage,
  tag,
}: {
  readonly configObject: Record;
  readonly packagePath: string;
  readonly isConfigsPackage: boolean;
  readonly tag: string;
}): Promise<PackageWithSourceConfigParameters> => {
  const withDescription = extractParam({
    configObject,
    parameterName: 'description',
    expectedType: 'string',
    extractedParams: {},
    tag,
  });

  const withDependencies = extractParam({
    configObject,
    parameterName: 'dependencies',
    expectedType: 'record',
    optionalValue: {},
    extractedParams: withDescription,
    tag,
  });

  const withDevDependencies = extractParam({
    configObject,
    parameterName: 'devDependencies',
    expectedType: 'record',
    optionalValue: {},
    extractedParams: withDependencies,
    tag,
  });

  const withPeerDependencies = extractParam({
    configObject,
    parameterName: 'peerDependencies',
    expectedType: 'record',
    optionalValue: {},
    extractedParams: withDevDependencies,
    tag,
  });

  const withExamples = extractParam({
    configObject,
    parameterName: 'examples',
    expectedType: 'array',
    optionalValue: [],
    extractedParams: withPeerDependencies,
    tag,
  });

  const withScripts = extractParam({
    configObject,
    parameterName: 'scripts',
    expectedType: 'record',
    optionalValue: {},
    extractedParams: withExamples,
    tag,
  });

  const withEnvironment = extractParam({
    configObject,
    parameterName: 'environment',
    expectedType: 'string',
    extractedParams: withScripts,
    tag,
  });

  const withBuildMethod = extractParam({
    configObject,
    parameterName: 'buildMethod',
    expectedType: 'string',
    extractedParams: withEnvironment,
    tag,
  });

  const withIsPublished = extractParam({
    configObject,
    parameterName: 'isPublished',
    expectedType: 'boolean',
    extractedParams: withBuildMethod,
    tag,
  });

  const withHasDocGen = extractParam({
    configObject,
    parameterName: 'hasDocGen',
    expectedType: 'boolean',
    extractedParams: withIsPublished,
    tag,
  });

  const withKeywords = extractParam({
    configObject,
    parameterName: 'keywords',
    expectedType: 'array',
    optionalValue: [],
    extractedParams: withHasDocGen,
    tag,
  });

  const withUseEffectAsPeerDependency = extractParam({
    configObject,
    parameterName: 'useEffectAsPeerDependency',
    expectedType: 'boolean',
    extractedParams: withKeywords,
    tag,
  });

  const withUseEffectPlatform = extractParam({
    configObject,
    parameterName: 'useEffectPlatform',
    expectedType: 'string',
    optionalValue: 'No',
    extractedParams: withUseEffectAsPeerDependency,
    tag,
  });

  const withPackagePrefix = extractParam({
    configObject,
    parameterName: 'packagePrefix',
    expectedType: 'string',
    extractedParams: withUseEffectPlatform,
    tag,
  });

  const extractedKeys = Object.keys(withPackagePrefix);
  const extraKeys = Object.keys(configObject).filter((key) => !extractedKeys.includes(key));
  if (extraKeys.length !== 0)
    throw new Error(
      `${tag}'${configFilename}' contains unexpected parameters for monorepo config: '${extraKeys.join("', '")}'`,
    );

  const packagePrefix = withPackagePrefix['packagePrefix'];

  const [autogeneratedIndexTs, autogeneratedImports] = await generateImports({
    sourcePath: join(packagePath, sourceFolderName),
    packagePrefix,
    keepFileExtensions: isConfigsPackage,
  });
  return {
    ...withPackagePrefix,
    autogeneratedIndexTs,
    autogeneratedImports,
  };
};

const decodeOnePackageRepoConfigObject = async ({
  configObject,
  repoPath,
  repoName,
  isConfigsPackage,
  repoTag,
}: {
  readonly configObject: Record;
  readonly repoPath: string;
  readonly repoName: string;
  readonly isConfigsPackage: boolean;
  readonly repoTag: string;
}): Promise<Config> => {
  console.log(`${repoTag}decoding one-package repo configuration file`);
  const params = await getConfigParamsForPackageWithSource({
    configObject,
    packagePath: repoPath,
    isConfigsPackage,
    tag: repoTag,
  });
  return configOnePackageRepo({ repoName, isConfigsPackage, ...params });
};

const decodeSubRepoConfigObject = async ({
  configObject,
  subRepoPath,
  subRepoName,
  repoName,
  subRepoTag,
}: {
  readonly configObject: Record;
  readonly subRepoPath: string;
  readonly subRepoName: string;
  readonly repoName: string;
  readonly subRepoTag: string;
}): Promise<Config> => {
  console.log(`${subRepoTag}decoding sub-repo configuration file`);
  const params = await getConfigParamsForPackageWithSource({
    configObject,
    packagePath: subRepoPath,
    isConfigsPackage: false,
    tag: subRepoTag,
  });
  return configSubRepo({ repoName, subRepoName, ...params });
};

const checkUselessFiles = async ({
  config,
  packagePath,
  isTopPackage,
  tag,
}: {
  readonly config: Config;
  readonly packagePath: string;
  readonly isTopPackage: boolean;
  readonly tag: string;
}): Promise<void> => {
  console.log(`${tag}determining potential useless files`);

  // In project.config.ts, paths are posix-Style. Let's convert them to OS style
  const filesToCreate = Object.keys(config).map(fromPosixPathToOSPath);

  const configFiles = await readFilesRecursively({
    path: packagePath,
    foldersToExclude: foldersGeneratedByThirdParties,
    dontFailOnInexistentPath: false,
  });

  const unexpectedConfigFiles = [
    ...configFiles
      .filter(
        ({ relativePath }) =>
          !filesToCreate.includes(relativePath)
          && !(
            isTopPackage ?
              patternsToIgnoreInTopPackageRegExp
            : patternsToIgnoreInOtherPackagesRegExp).test(relativePath),
      )
      .map(({ relativePath }) => relativePath),
    ...(
      await readFiles({
        path: join(packagePath, packagesFolderName),
        dontFailOnInexistentPath: true,
      })
    ).map((name) => `${packagesFolderName}/${name}`),
  ];

  if (unexpectedConfigFiles.length > 0)
    throw new Error(
      `${tag}following unexpected files where found in the package:\n${unexpectedConfigFiles.join(',\n')}`,
    );
};

const saveConfig = async ({
  config,
  packagePath,
  tag,
}: {
  readonly config: Config;
  readonly packagePath: string;
  readonly tag: string;
}): Promise<void> => {
  console.log(`${tag}writing configuration files`);
  for (const [filename, fileContent] of Object.entries(config)) {
    const contentToWriteFunc =
      extname(filename) === '.json' ? () => prettyStringify(fileContent)
      : typeof fileContent === 'string' ? () => fileContent
      : () => {
          throw new Error(
            `${tag}entry '${filename}' in '${configFilename}' must have value of type string`,
          );
        };

    const targetFilename = join(packagePath, filename);
    // Create directory in case it does not exist
    /* eslint-disable-next-line functional/no-expression-statements*/
    await mkdir(dirname(targetFilename), { recursive: true });

    /* eslint-disable-next-line functional/no-expression-statements*/
    await writeAutogeneratedFile({ path: targetFilename, newContents: contentToWriteFunc() });
  }
};

export const cleanProd = async ({
  packagePath,
  tag,
}: {
  readonly packagePath: string;
  readonly tag: string;
}) => {
  /* Remove dist directories because the packages will need rebuilding and these directories might contain conflicting versions of imported packages. We do it also in packages with no source, just in case... */
  console.log(`${tag}cleaning prod directories`);
  /* eslint-disable-next-line functional/no-expression-statements*/
  await rm(join(packagePath, prodFolderName), { force: true, recursive: true });
  /* eslint-disable-next-line functional/no-expression-statements*/
  await rm(join(packagePath, tsBuildInfoFolderName), { force: true, recursive: true });
};

const splitPath = resolve().split(sep);
const firstPackagesIndex = splitPath.findIndex((split) => split === packagesFolderName);
if (firstPackagesIndex <= 0) throw new Error('Could not find root of monorepo');
const topRepoPath = join(...splitPath.slice(0, firstPackagesIndex));
const topRepoName = splitPath[firstPackagesIndex - 1] as string;
const topRepoTag = `'${topRepoName}': `;

console.log(`Top repo '${topRepoName}' identified at: '${topRepoPath}'\n`);

const topPackagesPath = join(topRepoPath, packagesFolderName);
const repoNames = await readFolders({ path: topPackagesPath, dontFailOnInexistentPath: false });

const allPackages: ReadonlyArray<readonly [packageName: string, packagePath: string]> = (
  await Promise.all(
    repoNames.map(async (repoName) => {
      const repoTag = `  '${repoName}': `;
      const repoPath = join(topPackagesPath, repoName);
      const subPackagesPath = join(repoPath, packagesFolderName);
      const subRepos = await readFolders({
        path: subPackagesPath,
        dontFailOnInexistentPath: true,
      });

      const isConfigsPackage = repoName === configsPackageName;
      const isMonoRepo = subRepos.length === 0;

      const configObject = await readConfigFile({ path: repoPath, tag: repoTag });

      const config =
        isMonoRepo ?
          decodeMonoRepoConfigObject({ configObject, repoName, repoTag })
        : await decodeOnePackageRepoConfigObject({
            configObject,
            repoPath,
            repoName,
            repoTag,
            isConfigsPackage,
          });

      await checkUselessFiles({ config, packagePath: repoPath, isTopPackage: false, tag: repoTag });
      await saveConfig({ config, packagePath: repoPath, tag: repoTag });
      await cleanProd({ packagePath: repoPath, tag: repoTag });

      /* eslint-disable-next-line functional/no-expression-statements*/
      await Promise.all(
        subRepos.map(async (subRepoName) => {
          const subRepoTag = `    '${subRepoName}': `;
          const subRepoPath = join(subPackagesPath, subRepoName);

          const configObject = await readConfigFile({ path: subRepoPath, tag: subRepoTag });

          const config = await decodeSubRepoConfigObject({
            configObject,
            subRepoPath,
            subRepoName,
            repoName,
            subRepoTag,
          });

          await checkUselessFiles({
            config,
            packagePath: subRepoPath,
            isTopPackage: false,
            tag: subRepoTag,
          });
          await saveConfig({ config, packagePath: subRepoPath, tag: subRepoTag });
          await cleanProd({ packagePath: subRepoPath, tag: subRepoTag });
        }),
      );

      return [
        [repoName, `${packagesFolderName}/${repoName}`] as const,
        ...subRepos.map(
          (subRepoName) =>
            [
              subRepoName,
              `${packagesFolderName}/${repoName}/${packagesFolderName}/${subRepoName}`,
            ] as const,
        ),
      ];
    }),
  )
).flat();

const config = configTop({ topRepoName, description: 'Top repo of my developments', allPackages });
await checkUselessFiles({ config, packagePath: topRepoPath, isTopPackage: true, tag: topRepoTag });
await saveConfig({ config, packagePath: topRepoPath, tag: topRepoTag });
await cleanProd({ packagePath: topRepoPath, tag: topRepoTag });

console.log('SUCCESS');
