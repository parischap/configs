/**
 * This binary generates the configuration files, including the `index.ts` file for those packages that need autogeneration of that file.
 * 
 * If this binary is called at the level of the configs repo, it generates the configuration files at all levels (top, repos, subrepos). If it is called at any other level, it only generates the configuration files at that level.
 * 
 * Each package, except the top package, must contain a `project.config.json` file that contains the parameters of that package. The parameters of the top package are stored in this binary, so that the top package does not need to be saved on github. Based on the parameters, this binary creates a configuration object whose keys are the names of the files to create. If it's a `json` file, the associated value is converted from an object to a json
 * string with JSON.stringfy. Otherwise, the associated value must be a string and it is written as is.
 * 
 * This binary also checks that there are no unexpected config files present in the package, i.e config
 * files which are not created by this bin (there are a few exceptions: the `project.config.js` file
 * itself, the `README.md` file... see `patternsToIgnore` below).
 * 
 */
/* This module must not import any external dependency. It must be runnable without a package.json. It must only use Typescript syntax understandable by Node with the --experimental-transform-types flag */
import { mkdir, readFile, rm } from 'node:fs/promises';
import { basename, dirname, extname, join } from 'node:path';
import { generateImports } from '../internal/bin-utils/update-imports.js';
import configMonoRepo from '../internal/configs-generation/configMonoRepo.js';
import configOnePackageRepo from '../internal/configs-generation/configOnePackageRepo.js';
import configSubRepo from '../internal/configs-generation/configSubRepo.js';
import configTop from '../internal/configs-generation/configTop.js';
import {
  configFilename,
  configsPackageName,
  docsFolderName,
  githubFolderName,
  indexTsFilename,
  packageJsonFilename,
  packagesFolderName,
  pnpmLockFilename,
  prodFolderName,
  readMeFilename,
  topPackageName,
  viteTimeStampFilenamePattern,
  vscodeWorkspaceFilename,
} from '../internal/shared-utils/constants.js';
import {
  isReadonlyStringArray,
  isReadonlyStringRecord,
  isRecord,
  type Config,
} from '../internal/shared-utils/types.js';
import {
  fromPosixPathToOSPath,
  prettyStringify,
  readFolders,
  regExpEscape,
  simpleGlob,
  writeAutogeneratedFile,
} from '../internal/shared-utils/utils.js';

const fromPatternsToRegExp = (patterns: ReadonlyArray<string>): RegExp =>
  new RegExp(
    '^'
      + patterns.map((pattern) => regExpEscape(pattern).replace(/\*/g, '[^\\/]*')).join('|')
      + '$',
  );
// List of configuration files for which an error must not be reported if they are present in the package and not overridden by project.config.js
const patternsToIgnore = [readMeFilename, configFilename, viteTimeStampFilenamePattern];
const patternsToIgnoreRegExp = fromPatternsToRegExp(patternsToIgnore);

// more patterns added to patternsToIgnore only for the top repo
const topPatternsToIgnore = [pnpmLockFilename, vscodeWorkspaceFilename];
const topPatternsToIgnoreRegExp = fromPatternsToRegExp(topPatternsToIgnore);

// List of folders where configuration files might be found
const foldersToInclude = [githubFolderName, docsFolderName];

const getConfigFromConfigFile = async ({
  repoName,
  packageName,
  packagePath,
  isConfigsPackage
}: {
  readonly repoName: string;
  readonly packageName: string;
  readonly packagePath: string;
  readonly isConfigsPackage: boolean;
}): Promise<Config> => {
  const configFile = await readFile(join(packagePath, configFilename), 'utf8');

  const configParameters: unknown = JSON.parse(configFile);

  if (!isRecord(configParameters))
    throw new Error(
      `'${configFilename}' must contain the json representation of a non-null object`,
    );

  const configName = configParameters['configName'];

  if (configName === 'configMonoRepo') {
    const description = configParameters['description'];
    if (typeof description !== 'string')
      throw new Error(
        `Parameter 'description' of '${configFilename}' should be of type string'`,
      );

    const extraKeys = Object.keys(configParameters).filter(
      (key) => !['configName', 'description'].includes(key),
    );
    if (extraKeys.length !== 0)
      throw new Error(
        `'${configFilename}' contains unexpected parameters for config '${configName}': '${extraKeys.join("', '")}'`,
      );

    return configMonoRepo({ packageName, description });
  }

  if (configName === 'configOnePackageRepo' || configName === 'configSubRepo') {
    const description = configParameters['description'];
    if (typeof description !== 'string')
      throw new Error(
        `Parameter 'description' of '${configFilename}' should be of type string'`,
      );

    const dependencies = configParameters['dependencies'] ?? {};
    if (!isReadonlyStringRecord(dependencies))
      throw new Error(
        `Parameter 'dependencies' of '${configFilename}' should be of type ReadonlyStringRecord'`,
      );

    const devDependencies = configParameters['devDependencies'] ?? {};
    if (!isReadonlyStringRecord(devDependencies))
      throw new Error(
        `Parameter 'devDependencies' of '${configFilename}' should be of type ReadonlyStringRecord'`,
      );

    const peerDependencies = configParameters['peerDependencies'] ?? {};
    if (!isReadonlyStringRecord(peerDependencies))
      throw new Error(
        `Parameter 'peerDependencies' of '${configFilename}' should be of type ReadonlyStringRecord'`,
      );

    const examples = configParameters['examples'] ?? [];
    if (!isReadonlyStringArray(examples))
      throw new Error(
        `Parameter 'examples' of '${configFilename}' should be of type ReadonlyStringArray'`,
      );

    const scripts = configParameters['scripts'] ?? {};
    if (!isReadonlyStringRecord(scripts))
      throw new Error(
        `Parameter 'scripts' of '${configFilename}' should be of type ReadonlyStringRecord'`,
      );

    const environment = configParameters['environment'];
    if (typeof environment !== 'string')
      throw new Error(
        `Parameter 'environment' of '${configFilename}' should be of type string'`,
      );

    const buildMethod = configParameters['buildMethod'];
    if (typeof buildMethod !== 'string')
      throw new Error(
        `Parameter 'buildMethod' of '${configFilename}' should be of type string'`,
      );

    const isPublished = configParameters['isPublished'];
    if (typeof isPublished !== 'boolean')
      throw new Error(
        `Parameter 'isPublished' of '${configFilename}' should be of type boolean'`,
      );

    const hasDocGen = configParameters['hasDocGen'];
    if (typeof hasDocGen !== 'boolean')
      throw new Error(
        `Parameter 'hasDocGen' of '${configFilename}' should be of type boolean'`,
      );

    const keywords = configParameters['keywords'] ?? [];
    if (!isReadonlyStringArray(keywords))
      throw new Error(
        `Parameter 'keywords' of '${configFilename}' should be of type ReadonlyStringArray'`,
      );

    const useEffectAsPeerDependency = configParameters['useEffectAsPeerDependency'];
    if (typeof useEffectAsPeerDependency !== 'boolean')
      throw new Error(
        `Parameter 'useEffectAsPeerDependency' of '${configFilename}' should be of type boolean'`,
      );

    const useEffectPlatform = configParameters['useEffectPlatform'] ?? 'No';
    if (typeof useEffectPlatform !== 'string')
      throw new Error(
        `Parameter 'useEffectPlatform' of '${configFilename}' should be of type string'`,
      );

    const packagePrefix = configParameters['packagePrefix'];
    if (typeof packagePrefix !== 'string')
      throw new Error(
        `Parameter 'packagePrefix' of '${configFilename}' should be of type string'`,
      );

    const extraKeys = Object.keys(configParameters).filter(
      (key) =>
        ![
          'configName',
          'description',
          'dependencies',
          'devDependencies',
          'peerDependencies',
          'examples',
          'scripts',
          'environment',
          'buildMethod',
          'isPublished',
          'hasDocGen',
          'keywords',
          'useEffectAsPeerDependency',
          'useEffectPlatform',
          'packagePrefix',
        ].includes(key),
    );
    if (extraKeys.length !== 0)
      throw new Error(
        `'${configFilename}' contains unexpected parameters for config '${configName}': '${extraKeys.join("', '")}'`,
      );

    const config = configName === 'configOnePackageRepo' ?
      configOnePackageRepo({
        packageName,
        description,
        dependencies,
        devDependencies,
        peerDependencies,
        examples,
        scripts,
        environment,
        buildMethod,
        isPublished,
        hasDocGen,
        keywords,
        useEffectAsPeerDependency,
        useEffectPlatform,
        packagePrefix,
      }):

    configSubRepo({
      repoName,
      packageName,
      description,
      dependencies,
      devDependencies,
      peerDependencies,
      examples,
      scripts,
      environment,
      buildMethod,
      isPublished,
      hasDocGen,
      keywords,
      useEffectAsPeerDependency,
      useEffectPlatform,
      packagePrefix,
    });

if (packagePrefix === '') return config
  const [indexTsContents, packageJsonExports] = await generateImports({sourcePath:packagePath,packagePrefix,keepFileExtensions:isConfigsPackage})
  return {
    ...config,
    [indexTsFilename]: indexTsContents,
    [packageJsonFilename]: {
      ...config[packageJsonFilename],
      exports: packageJsonExports,
    }
  }
  }

  throw new Error(
    `'${configFilename}' contains unexpected value for configName parameter`,
  );
};


const applyConfig = async ({
  packagePath,
  repoName,
  packageName,
  isTopPackage,
  isConfigsPackage,
  indent,
}: {
  readonly packagePath: string;
  readonly repoName: string;
  readonly packageName: string;
  readonly isTopPackage: boolean;
  readonly isConfigsPackage: boolean;
  readonly indent:string
}) => {
  console.log(`${indent}Reading '${configFilename}'`);

  const config = isTopPackage ? configTop({ description:'Top repo of my developments' }): await getConfigFromConfigFile({ repoName, packageName, packagePath, isConfigsPackage });

  // In project.config.ts, paths are posix-Style. Let's convert them to OS style
  const filesToCreate = Object.keys(config).map(fromPosixPathToOSPath);
  
  console.log(`${indent}Determining potential conflicting configuration files`);

  const configFiles = (
    await Promise.all([
      simpleGlob({ path: packagePath, recursive: false, keepFilesOrFolders: 'Files' }),
      ...foldersToInclude.map((folderPath) =>
        simpleGlob({
          path: join(packagePath, folderPath),
          recursive: true,
          keepFilesOrFolders: 'Files',
          relativePathSource: packagePath,
        }),
      ),
    ])
  ).flat();

  const unexpectedConfigFiles = configFiles
    .filter(
      ({ relativePath }) =>
        !filesToCreate.includes(relativePath)
        && !patternsToIgnoreRegExp.test(relativePath)
        && !(isTopPackage || topPatternsToIgnoreRegExp.test(relativePath)),
    )
    .map(({ name }) => name);

  if (unexpectedConfigFiles.length > 0)
    throw new Error(
      'Following unexpected files where found in the package:\n'
        + unexpectedConfigFiles.join(',\n'),
    );

  console.log(`${indent}Writing configuration files`);
  for (const [filename, fileContent] of Object.entries(configWithExports)) {
    const contentToWriteFunc =
      extname(filename) === '.json' ? () => prettyStringify(fileContent)
      : typeof fileContent === 'string' ? () => fileContent
      : () => {
          throw new Error(
            `Entry '${filename}' in '${configFilename}' must have value of type string`,
          );
        };

    const targetFilename = join(packagePath, filename);
    // Create directory in case it does not exist
    /* eslint-disable-next-line functional/no-expression-statements*/
    await mkdir(dirname(targetFilename), { recursive: true });

    /* eslint-disable-next-line functional/no-expression-statements*/
    await writeAutogeneratedFile({path:targetFilename, newContents:contentToWriteFunc()});
  }
};

const packagePath = process.cwd();
const packageName = basename(packagePath);

if (packageName === configsPackageName) {
  console.log('Creating configuration files and updating imports for all packages');

  console.log('\nHandling top repo');
  const topPath = join('..', '..');
  /* eslint-disable-next-line functional/no-expression-statements*/
  await applyConfig({
    packagePath: topPath,
    repoName: topPackageName,
    packageName: topPackageName,
    isTopPackage: true,
    isConfigsPackage:false,
    indent:''
  });

  const topPackagesPath = join(topPath, packagesFolderName);
  const repoNames =
    await readFolders({ path: topPackagesPath, dontFailOnInexistentPath: false });

  /* eslint-disable-next-line functional/no-expression-statements*/
  await Promise.all(
    repoNames.map(async (repoName) => {
        const repoPath = join(topPackagesPath, repoName)
        const subPackagesPath = join(repoPath, packagesFolderName)
        const subRepos = await readFolders({
          path: subPackagesPath,
          dontFailOnInexistentPath: true,
        });

      const isMonoRepo = subRepos.length === 0;

      console.log(`\nHandling ${isMonoRepo ? 'monorepo' : 'one-package repo'} '${repoName}'`);

      await applyConfig({
        packagePath: repoPath,
        repoName,
        packageName: repoName,
        isTopPackage: false,
        isConfigsPackage: repoName === configsPackageName,
        indent:'  '
      });

      if (!isMonoRepo) {
          /* Remove dist directories of one-package repos because the packages will need rebuilding and these directories might contain conflicting versions of imported packages */
          console.log('  Removing dist directory');
          /* eslint-disable-next-line functional/no-expression-statements*/
          await rm(join(repoPath, prodFolderName), { force: true, recursive: true });
      }
      
      /* eslint-disable-next-line functional/no-expression-statements*/
      await Promise.all(
        subRepos.map(async (subRepoName) => {
          const subRepoPath = join(subPackagesPath, subRepoName)
          console.log(`  Handling subrepo ${subRepoName}`);
          console.log('    Removing dist directory');

          /* Remove dist directories of subrepos because the packages will need rebuilding and these directories might contain conflicting versions of imported packages */
          await rm(join(subRepoPath, prodFolderName), { force: true, recursive: true });
          await applyConfig({
            packagePath: subRepoPath,
            repoName,
            packageName: subRepoName,
            isTopPackage: false,
            isConfigsPackage:false,
            indent:'    '
          })
        }),
      );

    }),
  );
} else {
  console.log(`Creating configuration files and updating imports for package ${packageName}`);

  const [isTopPackage, repoName] =
    packageName === topPackageName ?
      [true, topPackageName]
    : ((name: string) => (name === topPackageName ? [false, packageName] : [false, name]))(
        basename(dirname(dirname(packagePath))),
      );

  /* eslint-disable-next-line functional/no-expression-statements*/
  await applyConfig({
    packagePath: '.',
    repoName,
    packageName,
    isTopPackage,
    isConfigsPackage:false,
    indent:''
  });
}

console.log('SUCCESS');
