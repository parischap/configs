/* This module must only use Typescript syntax understandable by Node with the --experimental-transform-types flag */
import {
  activePackageOnlyFlag,
  allJavaScriptExtensions,
  indexTsFilename,
  packageJsonFilename,
  packagePrefixFlag,
  sourceFolderName,
  watchFlag,
} from '../internal/shared-utils/constants.js';

import { watch } from 'node:fs/promises';
import { extname } from 'node:path';

import { readFile, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { isRecord } from '../internal/shared-utils/types.js';
import { prettyStringify, writeAutogeneratedFile } from '../internal/shared-utils/utils.js';

const updateImports = async ({
  packagePath,
  packagePrefix,
  keepFileExtensions,
  tag,
}: {
  readonly packagePath: string;
  readonly packagePrefix: string;
  readonly keepFileExtensions: boolean;
  readonly tag: string;
}) => {
  console.log(`${tag}Regenerating '${indexTsFilename}'`);

  const sourcePath = join(packagePath, sourceFolderName);
  const [indexTsContents, packageJsonExports] = await generateExports({
    sourcePath,
    packagePrefix,
    keepFileExtensions,
  });

  const indexTsPath = join(sourcePath, indexTsFilename);
  await writeAutogeneratedFile({ path: indexTsPath, newContents: indexTsContents });

  console.log(`${tag}Regenerating namespace exports in '${packageJsonFilename}'`);
  const packageJsonPath = join(packagePath, packageJsonFilename);
  /* eslint-disable-next-line functional/no-expression-statements */
  const packageJsonContent = await readFile(packageJsonPath, 'utf8');
  const packageJson: unknown = JSON.parse(packageJsonContent);

  if (!isRecord(packageJson))
    throw new Error(`${tag}'${packageJsonFilename}' must represent a record`);

  /* eslint-disable-next-line functional/no-expression-statements */
  await writeFile(
    packageJsonPath,
    prettyStringify({ ...packageJson, exports: packageJsonExports }),
  );
};

const command = process.argv[1] ?? 'update-exports';

const arg1 = process.argv[2] ?? '';

const firstEqualIndex = arg1.indexOf('=');
const packagePrefixName = arg1.slice(0, firstEqualIndex);
const packagePrefix = arg1.slice(firstEqualIndex + 1);
if (packagePrefixName !== packagePrefixFlag)
  throw new Error(`Bad '-packagePrefix' argument for '${command}' command. Actual: '${arg1}'`);

const arg2 = process.argv[3];
const arg3 = process.argv[4];
const isWatch = arg2 === watchFlag || arg3 === watchFlag;
const isActivePackageOnly = arg2 === activePackageOnlyFlag || arg3 === activePackageOnlyFlag;

if (mode === 'run')
  /* eslint-disable-next-line functional/no-expression-statements */
  await updateImports({
    packagePath: '.',
    packagePrefix,
    keepFileExtensions: isConfigsPackage,
    tag,
  });
else if (mode === 'watch') {
  let lastEventTime = Date.now();
  const watcher = watch(sourceFolderName, { recursive: true });
  for await (const event of watcher) {
    const currentEventTime = Date.now();
    // Avoid too many events. It's not that bad if we miss an event since we regenerate the whole file each time
    if (currentEventTime - lastEventTime > 500) {
      const changeFilename = event.filename;

      if (changeFilename === null)
        throw new Error('${tag]watch event does not include filename on this platform');
      if (
        changeFilename !== indexTsFilename
        && allJavaScriptExtensions.includes(extname(changeFilename))
      ) {
        /* eslint-disable-next-line functional/no-expression-statements */
        await updateImports({
          packagePath: '.',
          packagePrefix,
          keepFileExtensions: isConfigsPackage,
          tag,
        });
      }
    }
    /* eslint-disable-next-line functional/no-expression-statements */
    lastEventTime = currentEventTime;
  }
} else throw new Error(`${tag}expected argument 'run' or 'watch'. Actual: '${mode}'`);
