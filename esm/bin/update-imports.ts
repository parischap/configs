/* This module must only use Typescript syntax understandable by Node with the --experimental-transform-types flag */
import {
  allJavaScriptExtensions,
  configsPackageName,
  indexTsFilename,
  packageJsonFilename,
  sourceFolderName,
} from '../internal/shared-utils/constants.js';

import { watch } from 'node:fs/promises';
import { basename, extname } from 'node:path';

import { readFile, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { generateImports } from '../internal/bin-utils/generate-imports.js';
import { isRecord } from '../internal/shared-utils/types.js';
import { prettyStringify, writeAutogeneratedFile } from '../internal/shared-utils/utils.js';

const updateImports = async ({
  packagePath,
  packagePrefix,
  keepFileExtensions,
  tag,
}: {
  readonly packagePath: string;
  readonly packagePrefix: string;
  readonly keepFileExtensions: boolean;
  readonly tag: string;
}) => {
  console.log(`${tag}Regenerating '${indexTsFilename}'`);

  const sourcePath = join(packagePath, sourceFolderName);
  const [indexTsContents, packageJsonExports] = await generateImports({
    sourcePath,
    packagePrefix,
    keepFileExtensions,
  });

  const indexTsPath = join(sourcePath, indexTsFilename);
  await writeAutogeneratedFile({ path: indexTsPath, newContents: indexTsContents });

  console.log(`${tag}Regenerating namespace exports in '${packageJsonFilename}'`);
  const packageJsonPath = join(packagePath, packageJsonFilename);
  /* eslint-disable-next-line functional/no-expression-statements */
  const packageJsonContent = await readFile(packageJsonPath, 'utf8');
  const packageJson: unknown = JSON.parse(packageJsonContent);

  if (!isRecord(packageJson))
    throw new Error(`${tag}'${packageJsonFilename}' must represent a record`);

  /* eslint-disable-next-line functional/no-expression-statements */
  await writeFile(
    packageJsonPath,
    prettyStringify({ ...packageJson, exports: packageJsonExports }),
  );
};

const packageName = basename(process.cwd());
const tag = `'${packageName}': `;

const command = process.argv[1] ?? 'update-imports';
const mode = process.argv[2];
const packagePrefix = process.argv[3];

if (packagePrefix === undefined)
  throw new Error(`${tag}expected 'packagePrefix' argument for '${command}' command`);

const isConfigsPackage = packageName === configsPackageName;

if (mode === 'run')
  /* eslint-disable-next-line functional/no-expression-statements */
  await updateImports({
    packagePath: '.',
    packagePrefix,
    keepFileExtensions: isConfigsPackage,
    tag,
  });
else if (mode === 'watch') {
  let lastEventTime = Date.now();
  const watcher = watch(sourceFolderName, { recursive: true });
  for await (const event of watcher) {
    const currentEventTime = Date.now();
    // Avoid too many events. It's not that bad if we miss an event since we regenerate the whole file each time
    if (currentEventTime - lastEventTime > 500) {
      const changeFilename = event.filename;

      if (changeFilename === null)
        throw new Error('${tag]watch event does not include filename on this platform');
      if (
        changeFilename !== indexTsFilename
        && allJavaScriptExtensions.includes(extname(changeFilename))
      ) {
        /* eslint-disable-next-line functional/no-expression-statements */
        await updateImports({
          packagePath: '.',
          packagePrefix,
          keepFileExtensions: isConfigsPackage,
          tag,
        });
      }
    }
    /* eslint-disable-next-line functional/no-expression-statements */
    lastEventTime = currentEventTime;
  }
} else throw new Error(`${tag}expected argument 'run' or 'watch'. Actual: '${mode}'`);
