/* This module must only use Typescript syntax understandable by Node with the --experimental-transform-types flag */
import {
  autoGeneratedFileWarning,
  indexTsFilename,
  internalFolderName,
  javaScriptExtensions,
  sourceFolderName,
} from '../internal/constants.js';

import { readFile, watch, writeFile } from 'node:fs/promises';
import { dirname, extname, join } from 'node:path';
import { join as posixJoin } from 'node:path/posix';
import { simpleGlob } from '../internal/utils.js';

const capitalizeFirstLetter = (s: string): string => s.charAt(0).toUpperCase() + s.slice(1);

const action = async ({
  packageNameTag,
  packagePrefix,
}: {
  readonly packageNameTag: string;
  readonly packagePrefix: string;
}) => {
  console.log(`${packageNameTag}automatic '${indexTsFilename}' generation`);
  const indexPath = join(sourceFolderName, indexTsFilename);

  let noIndex = false;
  let indexContent = '';
  try {
    /* eslint-disable-next-line functional/no-expression-statements */
    indexContent = await readFile(indexPath, 'utf8');
    /* eslint-disable-next-line functional/no-expression-statements */
    noIndex = false;
  } catch (e: unknown) {
    if (e instanceof Error && 'code' in e && e['code'] === 'ENOENT')
      /* eslint-disable-next-line functional/no-expression-statements */
      noIndex = true;
    else throw e;
  }
  if (noIndex || indexContent.startsWith(autoGeneratedFileWarning)) {
    const sourceFiles = (
      await simpleGlob({ path: sourceFolderName, recursive: true, keepFilesOrFolders: 'Files' })
    ).filter(
      ({ name, extension, relativePath }) =>
        javaScriptExtensions.includes(extension)
        && !dirname(relativePath).startsWith(internalFolderName)
        && name !== indexTsFilename,
    );

    /* eslint-disable-next-line functional/no-expression-statements */
    await writeFile(
      indexPath,
      autoGeneratedFileWarning
        + '\n\n'
        + sourceFiles
          // path.join removes upfront './' but typescript requires them so we must add them
          .map(
            ({ bareName, relativePath }) =>
              `export * as ${packagePrefix}${capitalizeFirstLetter(bareName)} from './${posixJoin(relativePath, bareName)}.js';`,
          )
          .join('\n'),
    );
  } else
    throw new Error(`${packageNameTag}could not autogenerate '${indexTsFilename}' because the file already exists\
 and does not start with predefined warning comment`);
};

const command = process.argv[2];
const packageName = process.argv[3];
const packagePrefix = process.argv[4];

if (packageName === undefined) throw new Error("Expected 'packageName' argument");

const packageNameTag = `'${packageName}': `;
if (packagePrefix === undefined) throw new Error("Expected 'packagePrefix' argument");

if (command === 'run')
  /* eslint-disable-next-line functional/no-expression-statements */
  await action({ packageNameTag, packagePrefix });
else if (command === 'watch') {
  let lastEventTime = Date.now();
  const watcher = watch(sourceFolderName, { recursive: true });
  for await (const event of watcher) {
    const currentEventTime = Date.now();
    // Avoid too many events. It's not that bad if we miss an event since we regenerate the whole file each time
    if (currentEventTime - lastEventTime > 500) {
      const changeFilename = event.filename;

      if (changeFilename === null)
        throw new Error(`${packageNameTag}Watch event does not include filename on this platform`);
      if (
        changeFilename !== indexTsFilename
        && javaScriptExtensions.includes(extname(changeFilename))
      ) {
        /* eslint-disable-next-line functional/no-expression-statements */
        await action({ packageNameTag, packagePrefix });
      }
    }
    /* eslint-disable-next-line functional/no-expression-statements */
    lastEventTime = currentEventTime;
  }
} else throw new Error(`${packageNameTag}Expected argument 'run' or 'watch'. Actual: '${command}'`);
